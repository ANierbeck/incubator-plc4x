<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LittleEndianDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: ADS</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.ads.protocol.util</a> &gt; <span class="el_source">LittleEndianDecoder.java</span></div><h1>LittleEndianDecoder.java</h1><pre class="source lang-java linenums">/*
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 &quot;License&quot;); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */
package org.apache.plc4x.java.ads.protocol.util;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.plc4x.java.ads.model.AdsDataType;
import org.apache.plc4x.java.base.messages.items.*;

import java.io.ByteArrayOutputStream;
import java.math.BigInteger;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.LinkedList;

// TODO: we might user ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN).putInt(port).asArray() etc
public class LittleEndianDecoder {

    private LittleEndianDecoder() {
        // Utility class
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static FieldItem&lt;?&gt; decodeData(AdsDataType adsDataType, byte[] adsData) {
<span class="fc" id="L44">        ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(adsData);</span>
<span class="pc bpc" id="L45" title="34 of 42 branches missed.">        switch (adsDataType) {</span>
            case BIT: {
<span class="nc" id="L47">                LinkedList&lt;Boolean&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L49">                    short aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">                    values.offer(aByte != 0);</span>
<span class="nc" id="L51">                }</span>
<span class="nc" id="L52">                return new DefaultBooleanFieldItem(values.toArray(new Boolean[0]));</span>
            }
            case BIT8: {
<span class="nc" id="L55">                LinkedList&lt;Boolean&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L57">                    short aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">                    values.offer(aByte != 0);</span>
<span class="nc" id="L59">                }</span>
<span class="nc" id="L60">                return new DefaultBooleanFieldItem(values.toArray(new Boolean[0]));</span>
            }
            case BITARR8: {
<span class="nc" id="L63">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L65">                    short aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="nc" id="L66">                    values.offer((long) aByte);</span>
<span class="nc" id="L67">                }</span>
<span class="nc" id="L68">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case BITARR16: {
<span class="nc" id="L71">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L73">                    long aLong = wrappedBuffer.readUnsignedShortLE();</span>
<span class="nc" id="L74">                    values.offer(aLong);</span>
<span class="nc" id="L75">                }</span>
<span class="nc" id="L76">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case BITARR32: {
<span class="nc" id="L79">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L81">                    long aLong = wrappedBuffer.readUnsignedIntLE();</span>
<span class="nc" id="L82">                    values.offer(aLong);</span>
<span class="nc" id="L83">                }</span>
<span class="nc" id="L84">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case INT8: {
<span class="nc" id="L87">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L89">                    long aLong = wrappedBuffer.readByte();</span>
<span class="nc" id="L90">                    values.offer(aLong);</span>
<span class="nc" id="L91">                }</span>
<span class="nc" id="L92">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case INT16: {
<span class="nc" id="L95">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L97">                    long aLong = wrappedBuffer.readShortLE();</span>
<span class="nc" id="L98">                    values.offer(aLong);</span>
<span class="nc" id="L99">                }</span>
<span class="nc" id="L100">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case INT32: {
<span class="fc" id="L103">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L105">                    long aLong = wrappedBuffer.readIntLE();</span>
<span class="fc" id="L106">                    values.offer(aLong);</span>
<span class="fc" id="L107">                }</span>
<span class="fc" id="L108">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case INT64: {
<span class="fc" id="L111">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L113">                    byte[] bytes = new byte[8];</span>
<span class="fc" id="L114">                    wrappedBuffer.readBytes(bytes);</span>
<span class="fc" id="L115">                    BigInteger bigInteger = new BigInteger(bytes);</span>
                    // TODO: potential dataloss here.
<span class="fc" id="L117">                    values.offer(bigInteger.longValue());</span>
<span class="fc" id="L118">                }</span>
<span class="fc" id="L119">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UINT8: {
<span class="nc" id="L122">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L124">                    long aLong = wrappedBuffer.readUnsignedByte();</span>
<span class="nc" id="L125">                    values.offer(aLong);</span>
<span class="nc" id="L126">                }</span>
<span class="nc" id="L127">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UINT16: {
<span class="nc" id="L130">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L132">                    long aLong = wrappedBuffer.readUnsignedShortLE();</span>
<span class="nc" id="L133">                    values.offer(aLong);</span>
<span class="nc" id="L134">                }</span>
<span class="nc" id="L135">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UINT32: {
<span class="nc" id="L138">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L140">                    long aLong = wrappedBuffer.readUnsignedIntLE();</span>
<span class="nc" id="L141">                    values.offer(aLong);</span>
<span class="nc" id="L142">                }</span>
<span class="nc" id="L143">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UINT64: {
<span class="nc" id="L146">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L148">                    byte[] bytes = new byte[64];</span>
<span class="nc" id="L149">                    wrappedBuffer.readBytes(bytes);</span>
<span class="nc" id="L150">                    BigInteger bigInteger = new BigInteger(ArrayUtils.add(bytes, (byte) 0x0));</span>
                    // TODO: potential dataloss here.
<span class="nc" id="L152">                    values.offer(bigInteger.longValue());</span>
<span class="nc" id="L153">                }</span>
<span class="nc" id="L154">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case FLOAT: {
<span class="nc" id="L157">                LinkedList&lt;Double&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L159">                    double aLong = wrappedBuffer.readFloatLE();</span>
<span class="nc" id="L160">                    values.offer(aLong);</span>
<span class="nc" id="L161">                }</span>
<span class="nc" id="L162">                return new DefaultFloatingPointFieldItem(values.toArray(new Double[0]));</span>
            }
            case DOUBLE: {
<span class="nc" id="L165">                LinkedList&lt;Double&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L167">                    double aLong = wrappedBuffer.readDoubleLE();</span>
<span class="nc" id="L168">                    values.offer(aLong);</span>
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">                return new DefaultFloatingPointFieldItem(values.toArray(new Double[0]));</span>
            }
            case BOOL: {
<span class="fc" id="L173">                LinkedList&lt;Boolean&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L175">                    short aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                    values.offer(aByte != 0);</span>
<span class="fc" id="L177">                }</span>
<span class="fc" id="L178">                return new DefaultBooleanFieldItem(values.toArray(new Boolean[0]));</span>
            }
            case BYTE: {
<span class="fc" id="L181">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L183">                    long aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="fc" id="L184">                    values.offer(aByte);</span>
<span class="fc" id="L185">                }</span>
<span class="fc" id="L186">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case WORD: {
<span class="nc" id="L189">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L191">                    long aByte = wrappedBuffer.readUnsignedShortLE();</span>
<span class="nc" id="L192">                    values.offer(aByte);</span>
<span class="nc" id="L193">                }</span>
<span class="nc" id="L194">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case DWORD: {
<span class="nc" id="L197">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L199">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
<span class="nc" id="L200">                    values.offer(aByte);</span>
<span class="nc" id="L201">                }</span>
<span class="nc" id="L202">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case SINT: {
<span class="nc" id="L205">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L207">                    long aByte = wrappedBuffer.readByte();</span>
<span class="nc" id="L208">                    values.offer(aByte);</span>
<span class="nc" id="L209">                }</span>
<span class="nc" id="L210">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case USINT: {
<span class="nc" id="L213">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L215">                    long aByte = wrappedBuffer.readUnsignedByte();</span>
<span class="nc" id="L216">                    values.offer(aByte);</span>
<span class="nc" id="L217">                }</span>
<span class="nc" id="L218">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case INT: {
<span class="fc" id="L221">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L223">                    long aByte = wrappedBuffer.readShortLE();</span>
<span class="fc" id="L224">                    values.offer(aByte);</span>
<span class="fc" id="L225">                }</span>
<span class="fc" id="L226">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UINT: {
<span class="nc" id="L229">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L231">                    long aByte = wrappedBuffer.readUnsignedShortLE();</span>
<span class="nc" id="L232">                    values.offer(aByte);</span>
<span class="nc" id="L233">                }</span>
<span class="nc" id="L234">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case DINT: {
<span class="nc" id="L237">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L239">                    long aByte = wrappedBuffer.readIntLE();</span>
<span class="nc" id="L240">                    values.offer(aByte);</span>
<span class="nc" id="L241">                }</span>
<span class="nc" id="L242">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case UDINT: {
<span class="nc" id="L245">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L247">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
<span class="nc" id="L248">                    values.offer(aByte);</span>
<span class="nc" id="L249">                }</span>
<span class="nc" id="L250">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case LINT: {
<span class="nc" id="L253">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L255">                    long aByte = wrappedBuffer.readLongLE();</span>
<span class="nc" id="L256">                    values.offer(aByte);</span>
<span class="nc" id="L257">                }</span>
<span class="nc" id="L258">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case ULINT: {
<span class="nc" id="L261">                LinkedList&lt;Long&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L263">                    byte[] bytes = new byte[64];</span>
<span class="nc" id="L264">                    wrappedBuffer.readBytes(bytes);</span>
<span class="nc" id="L265">                    BigInteger bigInteger = new BigInteger(ArrayUtils.add(bytes, (byte) 0x0));</span>
                    // TODO: potential dataloss here.
<span class="nc" id="L267">                    values.offer(bigInteger.longValue());</span>
<span class="nc" id="L268">                }</span>
<span class="nc" id="L269">                return new DefaultIntegerFieldItem(values.toArray(new Long[0]));</span>
            }
            case REAL: {
<span class="fc" id="L272">                LinkedList&lt;Double&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L274">                    double aByte = wrappedBuffer.readFloatLE();</span>
<span class="fc" id="L275">                    values.offer(aByte);</span>
<span class="fc" id="L276">                }</span>
<span class="fc" id="L277">                return new DefaultFloatingPointFieldItem(values.toArray(new Double[0]));</span>
            }
            case LREAL: {
<span class="fc" id="L280">                LinkedList&lt;Double&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L282">                    double aByte = wrappedBuffer.readDoubleLE();</span>
<span class="fc" id="L283">                    values.offer(aByte);</span>
<span class="fc" id="L284">                }</span>
<span class="fc" id="L285">                return new DefaultFloatingPointFieldItem(values.toArray(new Double[0]));</span>
            }
            case STRING: {
<span class="fc" id="L288">                LinkedList&lt;String&gt; values = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                while (wrappedBuffer.isReadable()) {</span>
<span class="fc" id="L290">                    ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
                    Byte aByte;
<span class="fc bfc" id="L292" title="All 2 branches covered.">                    while ((aByte = wrappedBuffer.readByte()) != 0x0) {</span>
<span class="fc" id="L293">                        os.write(aByte);</span>
                    }
<span class="fc" id="L295">                    values.offer(new String(os.toByteArray()));</span>
<span class="fc" id="L296">                }</span>
<span class="fc" id="L297">                return new DefaultStringFieldItem(values.toArray(new String[0]));</span>
            }
            case TIME: {
<span class="nc" id="L300">                LinkedList&lt;LocalDateTime&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L302">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
                    // TODO: we can't map time to LocalDateTime. Implmentation broken currently
<span class="nc" id="L304">                    Instant instant = Instant.ofEpochMilli(aByte);</span>
<span class="nc" id="L305">                    values.offer(LocalDateTime.ofInstant(instant, ZoneId.of(&quot;ECT&quot;)));</span>
<span class="nc" id="L306">                }</span>
<span class="nc" id="L307">                return new DefaultTimeFieldItem(values.toArray(new LocalDateTime[0]));</span>
            }
            case TIME_OF_DAY: {
<span class="nc" id="L310">                LinkedList&lt;LocalDateTime&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L312">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
                    // TODO: we can't map time to LocalDateTime. Implmentation broken currently
<span class="nc" id="L314">                    Instant instant = Instant.ofEpochMilli(aByte);</span>
<span class="nc" id="L315">                    values.offer(LocalDateTime.ofInstant(instant, ZoneId.of(&quot;ECT&quot;)));</span>
<span class="nc" id="L316">                }</span>
<span class="nc" id="L317">                return new DefaultTimeFieldItem(values.toArray(new LocalDateTime[0]));</span>
            }
            case DATE: {
<span class="nc" id="L320">                LinkedList&lt;LocalDateTime&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L322">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
                    // TODO: we can't map time to LocalDateTime. Implmentation broken currently
<span class="nc" id="L324">                    Instant instant = Instant.ofEpochMilli(aByte);</span>
<span class="nc" id="L325">                    values.offer(LocalDateTime.ofInstant(instant, ZoneId.of(&quot;ECT&quot;)));</span>
<span class="nc" id="L326">                }</span>
<span class="nc" id="L327">                return new DefaultTimeFieldItem(values.toArray(new LocalDateTime[0]));</span>
            }
            case DATE_AND_TIME: {
<span class="nc" id="L330">                LinkedList&lt;LocalDateTime&gt; values = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                while (wrappedBuffer.isReadable()) {</span>
<span class="nc" id="L332">                    long aByte = wrappedBuffer.readUnsignedIntLE();</span>
                    // TODO: we can't map time to LocalDateTime. Implmentation broken currently
<span class="nc" id="L334">                    Instant instant = Instant.ofEpochMilli(aByte);</span>
<span class="nc" id="L335">                    values.offer(LocalDateTime.ofInstant(instant, ZoneId.of(&quot;ECT&quot;)));</span>
<span class="nc" id="L336">                }</span>
<span class="nc" id="L337">                return new DefaultTimeFieldItem(values.toArray(new LocalDateTime[0]));</span>
            }
            case ARRAY: {
<span class="nc" id="L340">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case POINTER: {
<span class="nc" id="L343">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case ENUM: {
<span class="nc" id="L346">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case STRUCT: {
<span class="nc" id="L349">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case ALIAS: {
<span class="nc" id="L352">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case SUB_RANGE_DATA_TYPE: {
<span class="nc" id="L355">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            case UNKNOWN: {
<span class="nc" id="L358">                throw new NotImplementedException(&quot;not implemented yet &quot; + adsDataType);</span>
            }
            default:
<span class="nc" id="L361">                throw new IllegalArgumentException(&quot;Unsupported adsDataType &quot; + adsDataType);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>
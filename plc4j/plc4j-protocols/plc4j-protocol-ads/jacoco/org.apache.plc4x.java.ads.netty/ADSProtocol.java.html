<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ADSProtocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: ADS</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.ads.netty</a> &gt; <span class="el_source">ADSProtocol.java</span></div><h1>ADSProtocol.java</h1><pre class="source lang-java linenums">/*
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 &quot;License&quot;); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */
package org.apache.plc4x.java.ads.netty;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageCodec;
import org.apache.plc4x.java.ads.api.commands.*;
import org.apache.plc4x.java.ads.api.commands.types.*;
import org.apache.plc4x.java.ads.api.commands.types.Length;
import org.apache.plc4x.java.ads.api.generic.AMSHeader;
import org.apache.plc4x.java.ads.api.generic.AMSTCPHeader;
import org.apache.plc4x.java.ads.api.generic.AMSTCPPacket;
import org.apache.plc4x.java.ads.api.generic.types.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class ADSProtocol extends MessageToMessageCodec&lt;ByteBuf, AMSTCPPacket&gt; {

<span class="fc" id="L42">    private static final Logger LOGGER = LoggerFactory.getLogger(ADSProtocol.class);</span>

    private final ConcurrentMap&lt;Invoke, AMSTCPPacket&gt; requests;

<span class="fc" id="L46">    public ADSProtocol() {</span>
<span class="fc" id="L47">        this.requests = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L48">    }</span>

    @Override
    protected void encode(ChannelHandlerContext channelHandlerContext, AMSTCPPacket amstcpPacket, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L52">        Invoke invokeId = amstcpPacket.getAmsHeader().getInvokeId();</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (invokeId != Invoke.NONE) {</span>
<span class="fc" id="L54">            requests.put(invokeId, amstcpPacket);</span>
        }
<span class="fc" id="L56">        out.add(amstcpPacket.getByteBuf());</span>
<span class="fc" id="L57">    }</span>


    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; out) throws Exception {
        // Reserved
<span class="fc" id="L64">        byteBuf.skipBytes(AMSTCPHeader.Reserved.NUM_BYTES);</span>
<span class="fc" id="L65">        long packetLength = byteBuf.readUnsignedIntLE();</span>
<span class="fc" id="L66">        AMSNetId targetAmsNetId = AMSNetId.of(byteBuf);</span>
<span class="fc" id="L67">        AMSPort targetAmsPort = AMSPort.of(byteBuf);</span>
<span class="fc" id="L68">        AMSNetId sourceAmsNetId = AMSNetId.of(byteBuf);</span>
<span class="fc" id="L69">        AMSPort sourceAmsPort = AMSPort.of(byteBuf);</span>
<span class="fc" id="L70">        Command commandId = Command.of(byteBuf);</span>
<span class="fc" id="L71">        State stateId = State.of(byteBuf);</span>
<span class="fc" id="L72">        DataLength dataLength = DataLength.of(byteBuf);</span>
<span class="fc" id="L73">        AMSError errorCode = AMSError.of(byteBuf);</span>
<span class="fc" id="L74">        Invoke invoke = Invoke.of(byteBuf);</span>
<span class="fc" id="L75">        AMSTCPPacket correlatedAmstcpPacket = requests.remove(invoke);</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (correlatedAmstcpPacket != null) {</span>
<span class="nc" id="L77">            LOGGER.debug(&quot;Correlated packet received {}&quot;, correlatedAmstcpPacket);</span>
        }
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (dataLength.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L80">            throw new IllegalStateException(&quot;Overflow in datalength: &quot; + dataLength.getAsLong());</span>
        }
<span class="fc" id="L82">        ByteBuf commandBuffer = byteBuf.readBytes((int) dataLength.getAsLong());</span>
<span class="fc" id="L83">        AMSTCPHeader amstcpHeader = AMSTCPHeader.of(packetLength);</span>
<span class="fc" id="L84">        AMSHeader amsHeader = AMSHeader.of(targetAmsNetId, targetAmsPort, sourceAmsNetId, sourceAmsPort, commandId, stateId, dataLength, errorCode, invoke);</span>
        final AMSTCPPacket amstcpPacket;
<span class="pc bpc" id="L86" title="2 of 11 branches missed.">        switch (commandId) {</span>
            case Invalid:
<span class="nc" id="L88">                amstcpPacket = UnknownCommand.of(amstcpHeader, amsHeader, commandBuffer);</span>
<span class="nc" id="L89">                break;</span>
            case ADS_Read_Device_Info:
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L92">                    amstcpPacket = ADSReadDeviceInfoRequest.of(amstcpHeader, amsHeader);</span>
                } else {
<span class="fc" id="L94">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L95">                    MajorVersion majorVersion = MajorVersion.of(commandBuffer);</span>
<span class="fc" id="L96">                    MinorVersion minorVersion = MinorVersion.of(commandBuffer);</span>
<span class="fc" id="L97">                    Version version = Version.of(commandBuffer);</span>
<span class="fc" id="L98">                    Device device = Device.of(commandBuffer);</span>
<span class="fc" id="L99">                    amstcpPacket = ADSReadDeviceInfoResponse.of(amstcpHeader, amsHeader, result, majorVersion, minorVersion, version, device);</span>
                }
<span class="fc" id="L101">                break;</span>
            case ADS_Read:
<span class="fc bfc" id="L103" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L104">                    IndexGroup indexGroup = IndexGroup.of(commandBuffer);</span>
<span class="fc" id="L105">                    IndexOffset indexOffset = IndexOffset.of(commandBuffer);</span>
<span class="fc" id="L106">                    Length length = Length.of(commandBuffer);</span>
<span class="fc" id="L107">                    amstcpPacket = ADSReadRequest.of(amstcpHeader, amsHeader, indexGroup, indexOffset, length);</span>
<span class="fc" id="L108">                } else {</span>
<span class="fc" id="L109">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L110">                    Length length = Length.of(commandBuffer);</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">                    if (length.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L112">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + length.getAsLong());</span>
                    }
<span class="fc" id="L114">                    byte[] dataToRead = new byte[(int) length.getAsLong()];</span>
<span class="fc" id="L115">                    commandBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L116">                    Data data = Data.of(dataToRead);</span>
<span class="fc" id="L117">                    amstcpPacket = ADSReadResponse.of(amstcpHeader, amsHeader, result, length, data);</span>
                }
<span class="fc" id="L119">                break;</span>
            case ADS_Write:
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L122">                    IndexGroup indexGroup = IndexGroup.of(commandBuffer);</span>
<span class="fc" id="L123">                    IndexOffset indexOffset = IndexOffset.of(commandBuffer);</span>
<span class="fc" id="L124">                    Length length = Length.of(commandBuffer);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                    if (length.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L126">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + length.getAsLong());</span>
                    }
<span class="fc" id="L128">                    byte[] dataToRead = new byte[(int) length.getAsLong()];</span>
<span class="fc" id="L129">                    commandBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L130">                    Data data = Data.of(dataToRead);</span>
<span class="fc" id="L131">                    amstcpPacket = ADSWriteRequest.of(amstcpHeader, amsHeader, indexGroup, indexOffset, length, data);</span>
<span class="fc" id="L132">                } else {</span>
<span class="fc" id="L133">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L134">                    amstcpPacket = ADSWriteResponse.of(amstcpHeader, amsHeader, result);</span>
                }
<span class="fc" id="L136">                break;</span>
            case ADS_Read_State:
<span class="fc bfc" id="L138" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L139">                    amstcpPacket = ADSReadStateRequest.of(amstcpHeader, amsHeader);</span>
                } else {
<span class="fc" id="L141">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L142">                    amstcpPacket = ADSReadStateResponse.of(amstcpHeader, amsHeader, result);</span>
                }
<span class="fc" id="L144">                break;</span>
            case ADS_Write_Control:
<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L147">                    ADSState adsState = ADSState.of(commandBuffer);</span>
<span class="fc" id="L148">                    DeviceState deviceState = DeviceState.of(commandBuffer);</span>
<span class="fc" id="L149">                    Length length = Length.of(commandBuffer);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                    if (length.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L151">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + length.getAsLong());</span>
                    }
<span class="fc" id="L153">                    byte[] dataToRead = new byte[(int) length.getAsLong()];</span>
<span class="fc" id="L154">                    commandBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L155">                    Data data = Data.of(dataToRead);</span>
<span class="fc" id="L156">                    amstcpPacket = ADSWriteControlRequest.of(amstcpHeader, amsHeader, adsState, deviceState, length, data);</span>
<span class="fc" id="L157">                } else {</span>
<span class="fc" id="L158">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L159">                    amstcpPacket = ADSWriteControlResponse.of(amstcpHeader, amsHeader, result);</span>
                }
<span class="fc" id="L161">                break;</span>
            case ADS_Add_Device_Notification:
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L164">                    IndexGroup indexGroup = IndexGroup.of(commandBuffer);</span>
<span class="fc" id="L165">                    IndexOffset indexOffset = IndexOffset.of(commandBuffer);</span>
<span class="fc" id="L166">                    Length length = Length.of(commandBuffer);</span>
<span class="fc" id="L167">                    TransmissionMode transmissionMode = TransmissionMode.of(commandBuffer);</span>
<span class="fc" id="L168">                    MaxDelay maxDelay = MaxDelay.of(commandBuffer);</span>
<span class="fc" id="L169">                    CycleTime cycleTime = CycleTime.of(commandBuffer);</span>
<span class="fc" id="L170">                    commandBuffer.skipBytes(ADSAddDeviceNotificationRequest.Reserved.NUM_BYTES);</span>
<span class="fc" id="L171">                    amstcpPacket = ADSAddDeviceNotificationRequest.of(amstcpHeader, amsHeader, indexGroup, indexOffset, length, transmissionMode, maxDelay, cycleTime);</span>
<span class="fc" id="L172">                } else {</span>
<span class="fc" id="L173">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L174">                    NotificationHandle notificationHandle = NotificationHandle.of(commandBuffer);</span>
<span class="fc" id="L175">                    amstcpPacket = ADSAddDeviceNotificationResponse.of(amstcpHeader, amsHeader, result, notificationHandle);</span>
                }
<span class="fc" id="L177">                break;</span>
            case ADS_Delete_Device_Notification:
<span class="fc bfc" id="L179" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L180">                    NotificationHandle notificationHandle = NotificationHandle.of(commandBuffer);</span>
<span class="fc" id="L181">                    amstcpPacket = ADSDeleteDeviceNotificationRequest.of(amstcpHeader, amsHeader, notificationHandle);</span>
<span class="fc" id="L182">                } else {</span>
<span class="fc" id="L183">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L184">                    amstcpPacket = ADSDeleteDeviceNotificationResponse.of(amstcpHeader, amsHeader, result);</span>
                }
<span class="fc" id="L186">                break;</span>
            case ADS_Device_Notification:
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L189">                    Length length = Length.of(commandBuffer);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                    if (length.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L191">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + length.getAsLong());</span>
                    }
<span class="fc" id="L193">                    Stamps stamps = Stamps.of(commandBuffer);</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                    if (stamps.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L195">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + stamps.getAsLong());</span>
                    }
<span class="fc" id="L197">                    ByteBuf adsDeviceNotificationBuffer = commandBuffer.readBytes((int) length.getAsLong());</span>
<span class="fc" id="L198">                    List&lt;AdsStampHeader&gt; adsStampHeaders = new ArrayList&lt;&gt;((int) stamps.getAsLong());</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                    for (int i = 1; i &lt;= stamps.getAsLong(); i++) {</span>
<span class="fc" id="L200">                        TimeStamp timeStamp = TimeStamp.of(adsDeviceNotificationBuffer);</span>
<span class="fc" id="L201">                        Samples samples = Samples.of(adsDeviceNotificationBuffer);</span>

<span class="fc" id="L203">                        List&lt;AdsNotificationSample&gt; adsNotificationSamples = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                        for (int j = 1; j &lt;= samples.getAsLong(); j++) {</span>
<span class="fc" id="L205">                            NotificationHandle notificationHandle = NotificationHandle.of(adsDeviceNotificationBuffer);</span>
<span class="fc" id="L206">                            SampleSize sampleSize = SampleSize.of(adsDeviceNotificationBuffer);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                            if (sampleSize.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L208">                                throw new IllegalStateException(&quot;Overflow in datalength: &quot; + sampleSize.getAsLong());</span>
                            }
                            // TODO: do we need a special marker class for: Notice: If your handle becomes invalid, one notification without data will be send once as advice.
<span class="fc" id="L211">                            byte[] dataToRead = new byte[(int) sampleSize.getAsLong()];</span>
<span class="fc" id="L212">                            adsDeviceNotificationBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L213">                            Data data = Data.of(dataToRead);</span>
<span class="fc" id="L214">                            AdsNotificationSample adsNotificationSample = AdsNotificationSample.of(notificationHandle, sampleSize, data);</span>
<span class="fc" id="L215">                            adsNotificationSamples.add(adsNotificationSample);</span>

                        }
<span class="fc" id="L218">                        AdsStampHeader adsStampHeader = AdsStampHeader.of(timeStamp, samples, adsNotificationSamples);</span>
<span class="fc" id="L219">                        adsStampHeaders.add(adsStampHeader);</span>
                    }
<span class="fc" id="L221">                    amstcpPacket = ADSDeviceNotificationRequest.of(amstcpHeader, amsHeader, length, stamps, adsStampHeaders);</span>
<span class="fc" id="L222">                } else {</span>
<span class="nc" id="L223">                    amstcpPacket = UnknownCommand.of(amstcpHeader, amsHeader, commandBuffer);</span>
                }
<span class="nc" id="L225">                break;</span>
            case ADS_Read_Write:
<span class="fc bfc" id="L227" title="All 2 branches covered.">                if (stateId.isRequest()) {</span>
<span class="fc" id="L228">                    IndexGroup indexGroup = IndexGroup.of(commandBuffer);</span>
<span class="fc" id="L229">                    IndexOffset indexOffset = IndexOffset.of(commandBuffer);</span>
<span class="fc" id="L230">                    ReadLength readLength = ReadLength.of(commandBuffer);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if (readLength.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L232">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + readLength.getAsLong());</span>
                    }
<span class="fc" id="L234">                    WriteLength writeLength = WriteLength.of(commandBuffer);</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                    if (writeLength.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L236">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + writeLength.getAsLong());</span>
                    }
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                    if (readLength.getAsLong() + writeLength.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L239">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + readLength.getAsLong() + writeLength.getAsLong());</span>
                    }
<span class="fc" id="L241">                    byte[] dataToRead = new byte[(int) readLength.getAsLong()];</span>
<span class="fc" id="L242">                    commandBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L243">                    Data data = Data.of(dataToRead);</span>
<span class="fc" id="L244">                    amstcpPacket = ADSReadWriteRequest.of(amstcpHeader, amsHeader, indexGroup, indexOffset, readLength, writeLength, data);</span>
<span class="fc" id="L245">                } else {</span>
<span class="fc" id="L246">                    Result result = Result.of(commandBuffer);</span>
<span class="fc" id="L247">                    Length length = Length.of(commandBuffer);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                    if (length.getAsLong() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L249">                        throw new IllegalStateException(&quot;Overflow in datalength: &quot; + length.getAsLong());</span>
                    }
<span class="fc" id="L251">                    byte[] dataToRead = new byte[(int) length.getAsLong()];</span>
<span class="fc" id="L252">                    commandBuffer.readBytes(dataToRead);</span>
<span class="fc" id="L253">                    Data data = Data.of(dataToRead);</span>
<span class="fc" id="L254">                    amstcpPacket = ADSReadWriteResponse.of(amstcpHeader, amsHeader, result, length, data);</span>
                }
<span class="fc" id="L256">                break;</span>
            case UNKNOWN:
            default:
<span class="nc" id="L259">                amstcpPacket = UnknownCommand.of(amstcpHeader, amsHeader, commandBuffer);</span>
        }
<span class="fc" id="L261">        out.add(amstcpPacket);</span>
<span class="fc" id="L262">        LOGGER.trace(&quot;Set amstcpPacket {} to out&quot;, amstcpPacket);</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (commandBuffer.readableBytes() &gt; 0) {</span>
<span class="nc" id="L264">            throw new IllegalStateException(&quot;Unread bytes left: &quot; + commandBuffer.readableBytes());</span>
        }
<span class="fc" id="L266">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>
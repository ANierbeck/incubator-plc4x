<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Plc4XS7Protocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: S7</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.s7.netty</a> &gt; <span class="el_source">Plc4XS7Protocol.java</span></div><h1>Plc4XS7Protocol.java</h1><pre class="source lang-java linenums">/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.plc4x.java.s7.netty;

import io.netty.channel.ChannelHandlerContext;
import org.apache.plc4x.java.api.exceptions.*;
import org.apache.plc4x.java.api.messages.*;
import org.apache.plc4x.java.api.messages.items.ReadRequestItem;
import org.apache.plc4x.java.api.messages.items.ReadResponseItem;
import org.apache.plc4x.java.api.messages.items.WriteRequestItem;
import org.apache.plc4x.java.api.messages.items.WriteResponseItem;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcReadRequest;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcReadResponse;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcWriteRequest;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcWriteResponse;
import org.apache.plc4x.java.api.model.Address;
import org.apache.plc4x.java.api.types.ResponseCode;
import org.apache.plc4x.java.base.PlcMessageToMessageCodec;
import org.apache.plc4x.java.base.events.ConnectedEvent;
import org.apache.plc4x.java.base.messages.PlcRequestContainer;
import org.apache.plc4x.java.s7.model.S7Address;
import org.apache.plc4x.java.s7.model.S7BitAddress;
import org.apache.plc4x.java.s7.model.S7DataBlockAddress;
import org.apache.plc4x.java.s7.netty.events.S7ConnectedEvent;
import org.apache.plc4x.java.s7.netty.model.messages.S7Message;
import org.apache.plc4x.java.s7.netty.model.messages.S7RequestMessage;
import org.apache.plc4x.java.s7.netty.model.messages.S7ResponseMessage;
import org.apache.plc4x.java.s7.netty.model.params.VarParameter;
import org.apache.plc4x.java.s7.netty.model.params.items.S7AnyVarParameterItem;
import org.apache.plc4x.java.s7.netty.model.params.items.VarParameterItem;
import org.apache.plc4x.java.s7.netty.model.payloads.VarPayload;
import org.apache.plc4x.java.s7.netty.model.payloads.items.VarPayloadItem;
import org.apache.plc4x.java.s7.netty.model.types.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.apache.plc4x.java.s7.netty.util.S7TypeDecoder.decodeData;
import static org.apache.plc4x.java.s7.netty.util.S7TypeEncoder.encodeData;

/**
 * This layer transforms between {@link PlcRequestContainer}s {@link S7Message}s.
 * And stores all &quot;in-flight&quot; requests in an internal structure ({@link Plc4XS7Protocol#requests}).
 *
 * While sending a request, a {@link S7RequestMessage} is generated and send downstream (to the {@link S7Protocol}.
 *
 * When a {@link S7ResponseMessage} is received it takes the existing request container from its Map and finishes
 * the {@link PlcRequestContainer}s future with the {@link PlcResponse}.
 */
public class Plc4XS7Protocol extends PlcMessageToMessageCodec&lt;S7Message, PlcRequestContainer&gt; {

<span class="fc" id="L69">    private static final AtomicInteger tpduGenerator = new AtomicInteger(1);</span>

    private Map&lt;Short, PlcRequestContainer&gt; requests;

<span class="fc" id="L73">    public Plc4XS7Protocol() {</span>
<span class="fc" id="L74">        this.requests = new HashMap&lt;&gt;();</span>
<span class="fc" id="L75">    }</span>

    /**
     * If this protocol layer catches an {@link S7ConnectedEvent} from the protocol layer beneath,
     * the connection establishment is finished.
     *
     * @param ctx the current protocol layers context
     * @param evt the event
     * @throws Exception throws an exception if something goes wrong internally
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (evt instanceof S7ConnectedEvent) {</span>
<span class="nc" id="L88">            ctx.channel().pipeline().fireUserEventTriggered(new ConnectedEvent());</span>
        } else {
<span class="nc" id="L90">            super.userEventTriggered(ctx, evt);</span>
        }
<span class="nc" id="L92">    }</span>

    /**
     * When receiving an error inside the pipeline, we have to find out which {@link PlcRequestContainer}
     * correlates needs to be notified about the problem. If a container is found, we can relay the
     * exception to that by calling completeExceptionally and passing in the exception.
     *
     * @param ctx   the current protocol layers context
     * @param cause the exception that was caught
     * @throws Exception throws an exception if something goes wrong internally
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (cause instanceof PlcProtocolPayloadTooBigException) {</span>
<span class="nc" id="L106">            PlcProtocolPayloadTooBigException pptbe = (PlcProtocolPayloadTooBigException) cause;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (pptbe.getPayload() instanceof S7RequestMessage) {</span>
<span class="nc" id="L108">                S7RequestMessage request = (S7RequestMessage) pptbe.getPayload();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                if (request.getParent() instanceof PlcRequestContainer) {</span>
<span class="nc" id="L110">                    PlcRequestContainer requestContainer = (PlcRequestContainer) request.getParent();</span>

                    // Remove the current request from the unconfirmed requests list.
<span class="nc" id="L113">                    requests.remove(request.getTpduReference());</span>

<span class="nc" id="L115">                    requestContainer.getResponseFuture().completeExceptionally(cause);</span>
                }
            }
<span class="nc bnc" id="L118" title="All 4 branches missed.">        } else if ((cause instanceof IOException) &amp;&amp; (cause.getMessage().contains(&quot;Connection reset by peer&quot;) ||</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            cause.getMessage().contains(&quot;Operation timed out&quot;))) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            String reason = cause.getMessage().contains(&quot;Connection reset by peer&quot;) ?</span>
                &quot;Connection terminated unexpectedly&quot; : &quot;Remote host not responding&quot;;
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (!requests.isEmpty()) {</span>
                // If the connection is hung up, all still pending requests can be closed.
<span class="nc bnc" id="L124" title="All 2 branches missed.">                for (PlcRequestContainer requestContainer : requests.values()) {</span>
<span class="nc" id="L125">                    requestContainer.getResponseFuture().completeExceptionally(new PlcIoException(reason));</span>
<span class="nc" id="L126">                }</span>
                // Clear the list
<span class="nc" id="L128">                requests.clear();</span>
            }
<span class="nc" id="L130">        } else {</span>
<span class="nc" id="L131">            super.exceptionCaught(ctx, cause);</span>
        }
<span class="nc" id="L133">    }</span>

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Encoding
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @Override
    protected void encode(ChannelHandlerContext ctx, PlcRequestContainer msg, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L141">        PlcRequest request = msg.getRequest();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (request instanceof PlcReadRequest) {</span>
<span class="fc" id="L143">            encodeReadRequest(msg, out);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        } else if (request instanceof PlcWriteRequest) {</span>
<span class="fc" id="L145">            encodeWriteRequest(msg, out);</span>
        }
<span class="fc" id="L147">    }</span>

    private void encodeReadRequest(PlcRequestContainer msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L150">        List&lt;VarParameterItem&gt; parameterItems = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L152">        PlcReadRequest readRequest = (PlcReadRequest) msg.getRequest();</span>
<span class="fc" id="L153">        encodeParameterItems(parameterItems, readRequest);</span>
<span class="fc" id="L154">        VarParameter readVarParameter = new VarParameter(ParameterType.READ_VAR, parameterItems);</span>

        // Assemble the request.
<span class="fc" id="L157">        S7RequestMessage s7ReadRequest = new S7RequestMessage(MessageType.JOB,</span>
<span class="fc" id="L158">            (short) tpduGenerator.getAndIncrement(), Collections.singletonList(readVarParameter),</span>
<span class="fc" id="L159">            Collections.emptyList(), msg);</span>

<span class="fc" id="L161">        requests.put(s7ReadRequest.getTpduReference(), msg);</span>

<span class="fc" id="L163">        out.add(s7ReadRequest);</span>
<span class="fc" id="L164">    }</span>

    private void encodeWriteRequest(PlcRequestContainer msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L167">        List&lt;VarParameterItem&gt; parameterItems = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L168">        List&lt;VarPayloadItem&gt; payloadItems = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L170">        PlcWriteRequest writeRequest = (PlcWriteRequest) msg.getRequest();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (WriteRequestItem requestItem : writeRequest.getRequestItems()) {</span>
            // Try to get the correct S7 transport size for the given data type.
            // (Map PLC4X data type to S7 data type)
<span class="fc" id="L174">            TransportSize transportSize = encodeTransportSize(requestItem.getDatatype());</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (transportSize == null) {</span>
<span class="nc" id="L176">                throw new PlcException(&quot;Unknown transport size for datatype &quot; + requestItem.getDatatype());</span>
            }

            // Depending on the address type, generate the corresponding type of request item.
<span class="fc" id="L180">            VarParameterItem varParameterItem = encodeVarParameterItem(</span>
<span class="fc" id="L181">                requestItem.getAddress(), transportSize, requestItem.getValues().size());</span>
<span class="fc" id="L182">            parameterItems.add(varParameterItem);</span>

<span class="fc" id="L184">            DataTransportSize dataTransportSize = encodeDataTransportSize(requestItem.getDatatype());</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (dataTransportSize == null) {</span>
<span class="nc" id="L186">                throw new PlcException(&quot;Unknown data transport size for datatype &quot; + requestItem.getDatatype());</span>
            }

<span class="fc" id="L189">            VarPayloadItem varPayloadItem = new VarPayloadItem(</span>
<span class="fc" id="L190">                DataTransportErrorCode.RESERVED, dataTransportSize, encodeData(requestItem.getValues().toArray()));</span>

<span class="fc" id="L192">            payloadItems.add(varPayloadItem);</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">        VarParameter writeVarParameter = new VarParameter(ParameterType.WRITE_VAR, parameterItems);</span>
<span class="fc" id="L195">        VarPayload writeVarPayload = new VarPayload(ParameterType.WRITE_VAR, payloadItems);</span>

        // Assemble the request.
<span class="fc" id="L198">        S7RequestMessage s7WriteRequest = new S7RequestMessage(MessageType.JOB,</span>
<span class="fc" id="L199">            (short) tpduGenerator.getAndIncrement(), Collections.singletonList(writeVarParameter),</span>
<span class="fc" id="L200">            Collections.singletonList(writeVarPayload), msg);</span>

<span class="fc" id="L202">        requests.put(s7WriteRequest.getTpduReference(), msg);</span>

<span class="fc" id="L204">        out.add(s7WriteRequest);</span>
<span class="fc" id="L205">    }</span>

    private void encodeParameterItems(List&lt;VarParameterItem&gt; parameterItems, PlcReadRequest readRequest) throws PlcException {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (ReadRequestItem requestItem : readRequest.getRequestItems()) {</span>
            // Try to get the correct S7 transport size for the given data type.
            // (Map PLC4X data type to S7 data type)
<span class="fc" id="L211">            TransportSize transportSize = encodeTransportSize(requestItem.getDatatype());</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (transportSize == null) {</span>
<span class="nc" id="L213">                throw new PlcException(&quot;Unknown transport size for datatype &quot; + requestItem.getDatatype());</span>
            }

            // Depending on the address type, generate the corresponding type of request item.
<span class="fc" id="L217">            VarParameterItem varParameterItem = encodeVarParameterItem(requestItem.getAddress(), transportSize, requestItem.getSize());</span>
<span class="fc" id="L218">            parameterItems.add(varParameterItem);</span>
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    private VarParameterItem encodeVarParameterItem(Address address, TransportSize transportSize, int size) throws PlcProtocolException {
        // Depending on the address type, generate the corresponding type of request item.
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (!(address instanceof S7Address)) {</span>
<span class="nc" id="L225">            throw new PlcProtocolException(&quot;Can only use S7Address types on S7 connection&quot;);</span>
        }
<span class="fc" id="L227">        S7Address s7Address = (S7Address) address;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (s7Address instanceof S7DataBlockAddress) {</span>
<span class="fc" id="L229">            S7DataBlockAddress s7DataBlockAddress = (S7DataBlockAddress) s7Address;</span>
<span class="fc" id="L230">            return new S7AnyVarParameterItem(</span>
<span class="fc" id="L231">                SpecificationType.VARIABLE_SPECIFICATION, s7Address.getMemoryArea(),</span>
                transportSize, (short) size,
<span class="fc" id="L233">                s7DataBlockAddress.getDataBlockNumber(), s7DataBlockAddress.getByteOffset(), (byte) 0);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        } else if (s7Address instanceof S7BitAddress) {</span>
<span class="fc" id="L235">            S7BitAddress s7BitAddress = (S7BitAddress) s7Address;</span>
<span class="fc" id="L236">            return new S7AnyVarParameterItem(</span>
<span class="fc" id="L237">                SpecificationType.VARIABLE_SPECIFICATION, s7Address.getMemoryArea(),</span>
                transportSize, (short) size, (short) 0,
<span class="fc" id="L239">                s7Address.getByteOffset(), s7BitAddress.getBitOffset());</span>
        } else {
<span class="fc" id="L241">            return new S7AnyVarParameterItem(</span>
<span class="fc" id="L242">                SpecificationType.VARIABLE_SPECIFICATION, s7Address.getMemoryArea(),</span>
                transportSize, (short) size, (short) 0,
<span class="fc" id="L244">                s7Address.getByteOffset(), (byte) 0);</span>
        }
    }

    private TransportSize encodeTransportSize(Class&lt;?&gt; datatype) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (datatype == Boolean.class) {</span>
<span class="fc" id="L250">            return TransportSize.BIT;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        } else if (datatype == Byte.class) {</span>
<span class="fc" id="L252">            return TransportSize.BYTE;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        } else if (datatype == Short.class) {</span>
<span class="fc" id="L254">            return TransportSize.WORD;</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        } else if (datatype == Calendar.class) {</span>
<span class="nc" id="L256">            return TransportSize.DATE_AND_TIME;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        } else if (datatype == Float.class) {</span>
<span class="fc" id="L258">            return TransportSize.REAL;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        } else if (datatype == Double.class) {</span>
<span class="fc" id="L260">            return TransportSize.REAL;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        } else if (datatype == Integer.class) {</span>
<span class="fc" id="L262">            return TransportSize.DWORD;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        } else if (datatype == String.class) {</span>
<span class="fc" id="L264">            return TransportSize.CHAR;</span>
        }
<span class="nc" id="L266">        return null;</span>
    }

    private DataTransportSize encodeDataTransportSize(Class&lt;?&gt; datatype) {
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (datatype == Boolean.class) {</span>
<span class="fc" id="L271">            return DataTransportSize.BIT;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        } else if (datatype == Byte.class) {</span>
<span class="fc" id="L273">            return DataTransportSize.BYTE_WORD_DWORD;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        } else if (datatype == Short.class) {</span>
<span class="fc" id="L275">            return DataTransportSize.BYTE_WORD_DWORD;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        } else if (datatype == Calendar.class) {</span>
            // TODO: Decide what to do here ...
<span class="nc" id="L278">            throw new PlcNotImplementedException(&quot;Calender support in S7 not yet implemented&quot;);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        } else if (datatype == Float.class) {</span>
<span class="fc" id="L280">            return DataTransportSize.REAL;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        } else if (datatype == Double.class) {</span>
<span class="fc" id="L282">            return DataTransportSize.REAL;</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        } else if (datatype == Integer.class) {</span>
<span class="fc" id="L284">            return DataTransportSize.BYTE_WORD_DWORD;</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        } else if (datatype == String.class) {</span>
<span class="fc" id="L286">            return DataTransportSize.OCTET_STRING;</span>
        }
<span class="nc" id="L288">        return null;</span>
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Decoding
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void decode(ChannelHandlerContext ctx, S7Message msg, List&lt;Object&gt; out) throws Exception {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (!(msg instanceof S7ResponseMessage)) {</span>
<span class="nc" id="L299">            return;</span>
        }
<span class="fc" id="L301">        S7ResponseMessage responseMessage = (S7ResponseMessage) msg;</span>
<span class="fc" id="L302">        short tpduReference = responseMessage.getTpduReference();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (requests.containsKey(tpduReference)) {</span>
<span class="fc" id="L304">            PlcRequestContainer requestContainer = requests.remove(tpduReference);</span>
<span class="fc" id="L305">            PlcRequest request = requestContainer.getRequest();</span>
<span class="fc" id="L306">            PlcResponse response = null;</span>

            // Handle the response to a read request.
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (request instanceof PlcReadRequest) {</span>
<span class="fc" id="L310">                response = decodeReadResponse(responseMessage, requestContainer);</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            } else if (request instanceof PlcWriteRequest) {</span>
<span class="fc" id="L312">                response = decodeWriteResponse(responseMessage, requestContainer);</span>
            }

            // Confirm the response being handled.
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (response != null) {</span>
<span class="fc" id="L317">                requestContainer.getResponseFuture().complete(response);</span>
            }
        }
<span class="fc" id="L320">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private PlcResponse decodeReadResponse(S7ResponseMessage responseMessage, PlcRequestContainer requestContainer) throws PlcProtocolException {
        PlcResponse response;
<span class="fc" id="L325">        PlcReadRequest plcReadRequest = (PlcReadRequest) requestContainer.getRequest();</span>

<span class="fc" id="L327">        List&lt;ReadResponseItem&lt;?&gt;&gt; responseItems = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L328">        VarPayload payload = responseMessage.getPayload(VarPayload.class)</span>
<span class="pc" id="L329">            .orElseThrow(() -&gt; new PlcProtocolException(&quot;No VarPayload supplied&quot;));</span>

        // If the numbers of items don't match, we're in big trouble as the only
        // way to know how to interpret the responses is by aligning them with the
        // items from the request as this information is not returned by the PLC.
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (plcReadRequest.getRequestItems().size() != payload.getItems().size()) {</span>
<span class="nc" id="L335">            throw new PlcProtocolException(</span>
                &quot;The number of requested items doesn't match the number of returned items&quot;);
        }

<span class="fc" id="L339">        List&lt;VarPayloadItem&gt; payloadItems = payload.getItems();</span>
<span class="fc" id="L340">        final int noPayLoadItems = payloadItems.size();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        for (int i = 0; i &lt; noPayLoadItems; i++) {</span>
<span class="fc" id="L342">            VarPayloadItem payloadItem = payloadItems.get(i);</span>

            // Get the request item for this payload item
<span class="fc" id="L345">            ReadRequestItem requestItem = plcReadRequest.getRequestItems().get(i);</span>

<span class="fc" id="L347">            ResponseCode responseCode = decodeResponseCode(payloadItem.getReturnCode());</span>

            ReadResponseItem responseItem;
            // Something went wrong.
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (responseCode != ResponseCode.OK) {</span>
<span class="nc" id="L352">                responseItem = new ReadResponseItem&lt;&gt;(requestItem, responseCode);</span>
            }
            // All Ok.
            else {
<span class="fc" id="L356">                byte[] data = payloadItem.getData();</span>
<span class="fc" id="L357">                Class&lt;?&gt; datatype = requestItem.getDatatype();</span>
<span class="fc" id="L358">                List&lt;?&gt; value = decodeData(datatype, data);</span>
<span class="fc" id="L359">                responseItem = new ReadResponseItem(requestItem, responseCode, value);</span>
            }
<span class="fc" id="L361">            responseItems.add(responseItem);</span>
        }
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (plcReadRequest instanceof TypeSafePlcReadRequest) {</span>
<span class="fc" id="L364">            response = new TypeSafePlcReadResponse((TypeSafePlcReadRequest) plcReadRequest, responseItems);</span>
        } else {
<span class="nc" id="L366">            response = new PlcReadResponse(plcReadRequest, responseItems);</span>
        }
<span class="fc" id="L368">        return response;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private PlcResponse decodeWriteResponse(S7ResponseMessage responseMessage, PlcRequestContainer requestContainer) throws PlcProtocolException {
        PlcResponse response;
<span class="fc" id="L374">        PlcWriteRequest plcWriteRequest = (PlcWriteRequest) requestContainer.getRequest();</span>
<span class="fc" id="L375">        List&lt;WriteResponseItem&lt;?&gt;&gt; responseItems = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L376">        VarPayload payload = responseMessage.getPayload(VarPayload.class)</span>
<span class="pc" id="L377">            .orElseThrow(() -&gt; new PlcProtocolException(&quot;No VarPayload supplied&quot;));</span>
        // If the numbers of items don't match, we're in big trouble as the only
        // way to know how to interpret the responses is by aligning them with the
        // items from the request as this information is not returned by the PLC.
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (plcWriteRequest.getRequestItems().size() != payload.getItems().size()) {</span>
<span class="nc" id="L382">            throw new PlcProtocolException(</span>
                &quot;The number of requested items doesn't match the number of returned items&quot;);
        }
<span class="fc" id="L385">        List&lt;VarPayloadItem&gt; payloadItems = payload.getItems();</span>
<span class="fc" id="L386">        final int noPayLoadItems = payloadItems.size();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">        for (int i = 0; i &lt; noPayLoadItems; i++) {</span>
<span class="fc" id="L388">            VarPayloadItem payloadItem = payloadItems.get(i);</span>

            // Get the request item for this payload item
<span class="fc" id="L391">            WriteRequestItem requestItem = plcWriteRequest.getRequestItems().get(i);</span>

            // A write response contains only the return code for every item.
<span class="fc" id="L394">            ResponseCode responseCode = decodeResponseCode(payloadItem.getReturnCode());</span>

<span class="fc" id="L396">            WriteResponseItem responseItem = new WriteResponseItem(requestItem, responseCode);</span>
<span class="fc" id="L397">            responseItems.add(responseItem);</span>
        }

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (plcWriteRequest instanceof TypeSafePlcWriteRequest) {</span>
<span class="fc" id="L401">            response = new TypeSafePlcWriteResponse((TypeSafePlcWriteRequest) plcWriteRequest, responseItems);</span>
        } else {
<span class="nc" id="L403">            response = new PlcWriteResponse(plcWriteRequest, responseItems);</span>
        }
<span class="fc" id="L405">        return response;</span>
    }

    private ResponseCode decodeResponseCode(DataTransportErrorCode dataTransportErrorCode) {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        if (dataTransportErrorCode == null) {</span>
<span class="nc" id="L410">            return ResponseCode.INTERNAL_ERROR;</span>
        }
<span class="pc bpc" id="L412" title="3 of 4 branches missed.">        switch (dataTransportErrorCode) {</span>
            case OK:
<span class="fc" id="L414">                return ResponseCode.OK;</span>
            case NOT_FOUND:
<span class="nc" id="L416">                return ResponseCode.NOT_FOUND;</span>
            case INVALID_ADDRESS:
<span class="nc" id="L418">                return ResponseCode.INVALID_ADDRESS;</span>
            default:
<span class="nc" id="L420">                return ResponseCode.INTERNAL_ERROR;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>
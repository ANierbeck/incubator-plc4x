<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Plc4XModbusProtocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Protocol: Modbus</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.modbus.netty</a> &gt; <span class="el_source">Plc4XModbusProtocol.java</span></div><h1>Plc4XModbusProtocol.java</h1><pre class="source lang-java linenums">/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.plc4x.java.modbus.netty;

import com.digitalpetri.modbus.ModbusPdu;
import com.digitalpetri.modbus.codec.ModbusTcpPayload;
import com.digitalpetri.modbus.requests.*;
import com.digitalpetri.modbus.responses.*;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageCodec;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.plc4x.java.api.exceptions.PlcException;
import org.apache.plc4x.java.api.exceptions.PlcProtocolException;
import org.apache.plc4x.java.api.exceptions.PlcRuntimeException;
import org.apache.plc4x.java.api.messages.*;
import org.apache.plc4x.java.api.messages.items.*;
import org.apache.plc4x.java.api.types.ResponseCode;
import org.apache.plc4x.java.modbus.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigInteger;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

public class Plc4XModbusProtocol extends MessageToMessageCodec&lt;ModbusTcpPayload, PlcRequestContainer&lt;PlcRequest, PlcResponse&gt;&gt; {

<span class="fc" id="L50">    private static final Logger LOGGER = LoggerFactory.getLogger(Plc4XModbusProtocol.class);</span>

<span class="fc" id="L52">    public final AtomicInteger transactionId = new AtomicInteger();</span>

<span class="fc" id="L54">    private final ConcurrentMap&lt;Short, PlcRequestContainer&lt;PlcRequest, PlcResponse&gt;&gt; requestsMap = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L56">    public Plc4XModbusProtocol() {</span>
<span class="fc" id="L57">    }</span>

    @Override
    protected void encode(ChannelHandlerContext ctx, PlcRequestContainer&lt;PlcRequest, PlcResponse&gt; msg, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L61">        LOGGER.trace(&quot;(&lt;--OUT): {}, {}, {}&quot;, ctx, msg, out);</span>
        // Reset transactionId on overflow
<span class="fc" id="L63">        transactionId.compareAndSet(Short.MAX_VALUE + 1, 0);</span>
<span class="fc" id="L64">        PlcRequest request = msg.getRequest();</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (request instanceof PlcReadRequest) {</span>
<span class="fc" id="L66">            encodeReadRequest(msg, out);</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        } else if (request instanceof PlcWriteRequest) {</span>
<span class="fc" id="L68">            encodeWriteRequest(msg, out);</span>
        }
<span class="fc" id="L70">    }</span>

    private void encodeWriteRequest(PlcRequestContainer&lt;PlcRequest, PlcResponse&gt; msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L73">        PlcWriteRequest request = (PlcWriteRequest) msg.getRequest();</span>
        // TODO: support multiple requests
<span class="pc" id="L75">        WriteRequestItem&lt;?&gt; writeRequestItem = request.getRequestItem().orElseThrow(() -&gt; new PlcProtocolException(&quot;Only single message supported for now&quot;));</span>
        // TODO: check if we can map like this. Implication is that we can only work with int, short, byte and boolean
        // TODO: for higher datatypes float, double etc we might need to split the bytes into chunks
<span class="fc" id="L78">        int quantity = writeRequestItem.getSize();</span>
<span class="fc" id="L79">        short unitId = 0;</span>
<span class="fc" id="L80">        checkSupportedDataType(writeRequestItem.getValues());</span>

<span class="fc" id="L82">        ModbusAddress address = (ModbusAddress) writeRequestItem.getAddress();</span>
        ModbusPdu modbusRequest;
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (address instanceof RegisterModbusAddress) {</span>
<span class="fc" id="L85">            RegisterModbusAddress registerModbusAddress = (RegisterModbusAddress) address;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            if (quantity &gt; 1) {</span>
<span class="fc" id="L87">                byte[] bytesToWrite = produceRegisterValue(writeRequestItem.getValues());</span>
<span class="fc" id="L88">                int requiredLength = 2 * quantity;</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">                if (bytesToWrite.length != requiredLength) {</span>
<span class="nc" id="L90">                    throw new PlcProtocolException(&quot;Invalid register values created. Should be at least quantity * 2 = N bytes. Was &quot; + bytesToWrite.length + &quot;, expected &quot; + requiredLength);</span>
                }
<span class="fc" id="L92">                modbusRequest = new WriteMultipleRegistersRequest(registerModbusAddress.getAddress(), quantity, bytesToWrite);</span>
<span class="fc" id="L93">            } else {</span>
<span class="fc" id="L94">                byte[] register = produceRegisterValue(writeRequestItem.getValues());</span>
<span class="fc" id="L95">                int intToWrite = register[0] &lt;&lt; 8 | register[1];</span>
<span class="fc" id="L96">                modbusRequest = new WriteSingleRegisterRequest(registerModbusAddress.getAddress(), intToWrite);</span>
            }
<span class="fc bfc" id="L98" title="All 2 branches covered.">        } else if (address instanceof CoilModbusAddress) {</span>
<span class="fc" id="L99">            CoilModbusAddress coilModbusAddress = (CoilModbusAddress) address;</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">            if (quantity &gt; 1) {</span>
<span class="fc" id="L101">                byte[] bytesToWrite = produceCoilValues(writeRequestItem.getValues());</span>
<span class="fc" id="L102">                int requiredLength = (quantity + 7) / 8;</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">                if (bytesToWrite.length != requiredLength) {</span>
<span class="nc" id="L104">                    throw new PlcProtocolException(&quot;Invalid coil values created. Should be at least (quantity + 7) / 8 = N bytes. Was &quot; + bytesToWrite.length + &quot;, expected &quot; + requiredLength);</span>
                }
<span class="fc" id="L106">                modbusRequest = new WriteMultipleCoilsRequest(coilModbusAddress.getAddress(), quantity, bytesToWrite);</span>
<span class="fc" id="L107">            } else {</span>
<span class="fc" id="L108">                boolean booleanToWrite = produceCoilValue(writeRequestItem.getValues());</span>
<span class="fc" id="L109">                modbusRequest = new WriteSingleCoilRequest(coilModbusAddress.getAddress(), booleanToWrite);</span>
            }
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        } else if (address instanceof MaskWriteRegisterModbusAddress) {</span>
<span class="fc" id="L112">            MaskWriteRegisterModbusAddress maskWriteRegisterModbusAddress = (MaskWriteRegisterModbusAddress) address;</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (quantity &gt; 1) {</span>
<span class="nc" id="L114">                throw new PlcProtocolException(&quot;Mask write request can only write one value&quot;);</span>
            } else {
                // TODO: this should be better part of the payload not the addressing.
<span class="fc" id="L117">                int andMask = maskWriteRegisterModbusAddress.getAndMask();</span>
<span class="fc" id="L118">                int orMask = maskWriteRegisterModbusAddress.getOrMask();</span>
<span class="fc" id="L119">                modbusRequest = new MaskWriteRegisterRequest(maskWriteRegisterModbusAddress.getAddress(), andMask, orMask);</span>
            }
<span class="fc" id="L121">        } else {</span>
<span class="nc" id="L122">            throw new PlcProtocolException(&quot;Unsupported address type &quot; + address.getClass() + &quot; for a write request.&quot;);</span>
        }
<span class="fc" id="L124">        short transactionId = (short) this.transactionId.getAndIncrement();</span>
<span class="fc" id="L125">        requestsMap.put(transactionId, msg);</span>
<span class="fc" id="L126">        out.add(new ModbusTcpPayload(transactionId, unitId, modbusRequest));</span>
<span class="fc" id="L127">    }</span>

    private void encodeReadRequest(PlcRequestContainer&lt;PlcRequest, PlcResponse&gt; msg, List&lt;Object&gt; out) throws PlcException {
<span class="fc" id="L130">        PlcReadRequest request = (PlcReadRequest) msg.getRequest();</span>
        // TODO: support multiple requests
<span class="pc" id="L132">        ReadRequestItem&lt;?&gt; readRequestItem = request.getRequestItem().orElseThrow(() -&gt; new PlcProtocolException(&quot;Only single message supported for now&quot;));</span>
        // TODO: check if we can map like this. Implication is that we can only work with int, short, byte and boolean
        // TODO: for higher datatypes float, double etc we might need to split the bytes into chunks
<span class="fc" id="L135">        int quantity = readRequestItem.getSize();</span>
        // TODO: the unit the should be used for multiple Requests
<span class="fc" id="L137">        short unitId = 0;</span>

<span class="fc" id="L139">        ModbusAddress address = (ModbusAddress) readRequestItem.getAddress();</span>
        ModbusPdu modbusRequest;
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (address instanceof CoilModbusAddress) {</span>
<span class="fc" id="L142">            CoilModbusAddress coilModbusAddress = (CoilModbusAddress) address;</span>
<span class="fc" id="L143">            modbusRequest = new ReadCoilsRequest(coilModbusAddress.getAddress(), quantity);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        } else if (address instanceof RegisterModbusAddress) {</span>
<span class="nc" id="L145">            RegisterModbusAddress registerModbusAddress = (RegisterModbusAddress) address;</span>
<span class="nc" id="L146">            modbusRequest = new ReadHoldingRegistersRequest(registerModbusAddress.getAddress(), quantity);</span>
<span class="pc bfc" id="L147" title="All 2 branches covered.">        } else if (address instanceof ReadDiscreteInputsModbusAddress) {</span>
<span class="fc" id="L148">            ReadDiscreteInputsModbusAddress readDiscreteInputsModbusAddress = (ReadDiscreteInputsModbusAddress) address;</span>
<span class="fc" id="L149">            modbusRequest = new ReadDiscreteInputsRequest(readDiscreteInputsModbusAddress.getAddress(), quantity);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        } else if (address instanceof ReadHoldingRegistersModbusAddress) {</span>
<span class="fc" id="L151">            ReadHoldingRegistersModbusAddress readHoldingRegistersModbusAddress = (ReadHoldingRegistersModbusAddress) address;</span>
<span class="fc" id="L152">            modbusRequest = new ReadHoldingRegistersRequest(readHoldingRegistersModbusAddress.getAddress(), quantity);</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        } else if (address instanceof ReadInputRegistersModbusAddress) {</span>
<span class="fc" id="L154">            ReadInputRegistersModbusAddress readInputRegistersModbusAddress = (ReadInputRegistersModbusAddress) address;</span>
<span class="fc" id="L155">            modbusRequest = new ReadInputRegistersRequest(readInputRegistersModbusAddress.getAddress(), quantity);</span>
<span class="fc" id="L156">        } else {</span>
<span class="nc" id="L157">            throw new PlcProtocolException(&quot;Unsupported address type &quot; + address.getClass() + &quot; for a read request.&quot;);</span>
        }
<span class="fc" id="L159">        short transactionId = (short) this.transactionId.getAndIncrement();</span>
<span class="fc" id="L160">        requestsMap.put(transactionId, msg);</span>
<span class="fc" id="L161">        out.add(new ModbusTcpPayload(transactionId, unitId, modbusRequest));</span>
<span class="fc" id="L162">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected void decode(ChannelHandlerContext ctx, ModbusTcpPayload msg, List&lt;Object&gt; out) throws Exception {
<span class="fc" id="L167">        LOGGER.trace(&quot;(--&gt;IN): {}, {}, {}&quot;, ctx, msg, out);</span>
<span class="fc" id="L168">        LOGGER.debug(&quot;{}: transactionId: {}, unitId: {}, modbusPdu:{}&quot;, msg, msg.getTransactionId(), msg.getUnitId(), msg.getModbusPdu());</span>
        // TODO: implement me
<span class="fc" id="L170">        short transactionId = msg.getTransactionId();</span>
<span class="fc" id="L171">        PlcRequestContainer&lt;PlcRequest, PlcResponse&gt; plcRequestContainer = requestsMap.get(transactionId);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (plcRequestContainer == null) {</span>
<span class="nc" id="L173">            throw new PlcProtocolException(&quot;Unrelated payload received. [transactionId: &quot; + msg.getTransactionId() + &quot;, unitId: &quot; + msg.getUnitId() + &quot;, modbusPdu: &quot; + msg.getModbusPdu() + &quot;]&quot;);</span>
        }

        // TODO: only single Item supported for now
<span class="fc" id="L177">        PlcRequest&lt;?&gt; request = plcRequestContainer.getRequest();</span>
<span class="pc" id="L178">        RequestItem requestItem = request.getRequestItem().orElseThrow(() -&gt; new PlcProtocolException(&quot;Only single message supported for now&quot;));</span>
<span class="fc" id="L179">        Class&lt;?&gt; dataType = requestItem.getDatatype();</span>

<span class="fc" id="L181">        ModbusPdu modbusPdu = msg.getModbusPdu();</span>
<span class="fc" id="L182">        short unitId = msg.getUnitId();</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (modbusPdu instanceof WriteMultipleCoilsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L186">            WriteMultipleCoilsResponse writeMultipleCoilsResponse = (WriteMultipleCoilsResponse) modbusPdu;</span>
<span class="fc" id="L187">            LOGGER.debug(&quot;{}: address:{}, quantity:{}&quot;, writeMultipleCoilsResponse, writeMultipleCoilsResponse.getAddress(), writeMultipleCoilsResponse.getQuantity());</span>
<span class="fc" id="L188">            plcRequestContainer.getResponseFuture().complete(new PlcWriteResponse((PlcWriteRequest) request, new WriteResponseItem&lt;&gt;((WriteRequestItem) requestItem, ResponseCode.OK)));</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteMultipleRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L191">            WriteMultipleRegistersResponse writeMultipleRegistersResponse = (WriteMultipleRegistersResponse) modbusPdu;</span>
<span class="fc" id="L192">            LOGGER.debug(&quot;{}: address:{}, quantity:{}&quot;, writeMultipleRegistersResponse, writeMultipleRegistersResponse.getAddress(), writeMultipleRegistersResponse.getQuantity());</span>
<span class="fc" id="L193">            plcRequestContainer.getResponseFuture().complete(new PlcWriteResponse((PlcWriteRequest) request, new WriteResponseItem&lt;&gt;((WriteRequestItem) requestItem, ResponseCode.OK)));</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteSingleCoilResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L196">            WriteSingleCoilResponse writeSingleCoilResponse = (WriteSingleCoilResponse) modbusPdu;</span>
<span class="fc" id="L197">            LOGGER.debug(&quot;{}: address:{}, value:{}&quot;, writeSingleCoilResponse, writeSingleCoilResponse.getAddress(), writeSingleCoilResponse.getValue());</span>
<span class="fc" id="L198">            plcRequestContainer.getResponseFuture().complete(new PlcWriteResponse((PlcWriteRequest) request, new WriteResponseItem&lt;&gt;((WriteRequestItem) requestItem, ResponseCode.OK)));</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        } else if (modbusPdu instanceof WriteSingleRegisterResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L201">            WriteSingleRegisterResponse writeSingleRegisterResponse = (WriteSingleRegisterResponse) modbusPdu;</span>
<span class="fc" id="L202">            LOGGER.debug(&quot;{}: address:{}, value:{}&quot;, writeSingleRegisterResponse, writeSingleRegisterResponse.getAddress(), writeSingleRegisterResponse.getValue());</span>
<span class="fc" id="L203">            plcRequestContainer.getResponseFuture().complete(new PlcWriteResponse((PlcWriteRequest) request, new WriteResponseItem&lt;&gt;((WriteRequestItem) requestItem, ResponseCode.OK)));</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadCoilsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L206">            ReadCoilsResponse readCoilsResponse = (ReadCoilsResponse) modbusPdu;</span>
<span class="fc" id="L207">            LOGGER.debug(&quot;{}: Nothing&quot;, readCoilsResponse);</span>
<span class="fc" id="L208">            ByteBuf byteBuf = readCoilsResponse.getCoilStatus();</span>
<span class="fc" id="L209">            List&lt;?&gt; data = produceCoilValueList(requestItem, dataType, byteBuf);</span>
<span class="fc" id="L210">            plcRequestContainer.getResponseFuture().complete(new PlcReadResponse((PlcReadRequest) request, new ReadResponseItem((ReadRequestItem) requestItem, ResponseCode.OK, data)));</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadDiscreteInputsResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L213">            ReadDiscreteInputsResponse readDiscreteInputsResponse = (ReadDiscreteInputsResponse) modbusPdu;</span>
<span class="fc" id="L214">            LOGGER.debug(&quot;{}: Nothing&quot;, readDiscreteInputsResponse);</span>
<span class="fc" id="L215">            ByteBuf byteBuf = readDiscreteInputsResponse.getInputStatus();</span>
<span class="fc" id="L216">            List&lt;?&gt; data = produceCoilValueList(requestItem, dataType, byteBuf);</span>
<span class="fc" id="L217">            plcRequestContainer.getResponseFuture().complete(new PlcReadResponse((PlcReadRequest) request, new ReadResponseItem((ReadRequestItem) requestItem, ResponseCode.OK, data)));</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadHoldingRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L220">            ReadHoldingRegistersResponse readHoldingRegistersResponse = (ReadHoldingRegistersResponse) modbusPdu;</span>
<span class="fc" id="L221">            LOGGER.debug(&quot;{}: Nothing&quot;, readHoldingRegistersResponse);</span>
<span class="fc" id="L222">            ByteBuf byteBuf = readHoldingRegistersResponse.getRegisters();</span>
            // TODO: use register method
<span class="fc" id="L224">            List&lt;?&gt; data = produceRegisterValueList(requestItem, dataType, byteBuf);</span>
<span class="fc" id="L225">            plcRequestContainer.getResponseFuture().complete(new PlcReadResponse((PlcReadRequest) request, new ReadResponseItem((ReadRequestItem) requestItem, ResponseCode.OK, data)));</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        } else if (modbusPdu instanceof ReadInputRegistersResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L228">            ReadInputRegistersResponse readInputRegistersResponse = (ReadInputRegistersResponse) modbusPdu;</span>
<span class="fc" id="L229">            LOGGER.debug(&quot;{}: Nothing&quot;, readInputRegistersResponse);</span>
<span class="fc" id="L230">            ByteBuf byteBuf = readInputRegistersResponse.getRegisters();</span>
            // TODO: use register method
<span class="fc" id="L232">            List&lt;?&gt; data = produceRegisterValueList(requestItem, dataType, byteBuf);</span>
<span class="fc" id="L233">            plcRequestContainer.getResponseFuture().complete(new PlcReadResponse((PlcReadRequest) request, new ReadResponseItem((ReadRequestItem) requestItem, ResponseCode.OK, data)));</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        } else if (modbusPdu instanceof MaskWriteRegisterResponse) {</span>
            // TODO: finish implementation
<span class="fc" id="L236">            MaskWriteRegisterResponse maskWriteRegisterResponse = (MaskWriteRegisterResponse) modbusPdu;</span>
<span class="fc" id="L237">            LOGGER.debug(&quot;{}: Nothing&quot;, maskWriteRegisterResponse);</span>
<span class="fc" id="L238">            plcRequestContainer.getResponseFuture().complete(new PlcWriteResponse((PlcWriteRequest) request, new WriteResponseItem&lt;&gt;((WriteRequestItem) requestItem, ResponseCode.OK)));</span>
<span class="pc bnc" id="L239" title="All 2 branches missed.">        } else if (modbusPdu instanceof ExceptionResponse) {</span>
<span class="nc" id="L240">            ExceptionResponse exceptionResponse = (ExceptionResponse) modbusPdu;</span>
<span class="nc" id="L241">            throw new PlcProtocolException(&quot;Error received &quot; + exceptionResponse.getExceptionCode());</span>
        } else {
<span class="nc" id="L243">            throw new PlcProtocolException(&quot;Unsupported messageTyp type&quot; + modbusPdu.getClass());</span>
        }
<span class="fc" id="L245">    }</span>

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc" id="L249">        LOGGER.trace(&quot;(--&gt;ERR): {}&quot;, ctx, cause);</span>
<span class="nc" id="L250">        super.exceptionCaught(ctx, cause);</span>
<span class="nc" id="L251">    }</span>

    private void checkSupportedDataType(List&lt;?&gt; values) {
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">        if (values == null || values.size() == 0) {</span>
<span class="nc" id="L255">            return;</span>
        }
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (Object value : values) {</span>
<span class="pc bpc" id="L258" title="2 of 16 branches missed.">            if (</span>
                !(value instanceof Boolean)
                    &amp;&amp; !(value instanceof Byte)
                    &amp;&amp; !(value instanceof byte[])
                    &amp;&amp; !(value instanceof Short)
                    &amp;&amp; !(value instanceof Integer)
                    &amp;&amp; !(value instanceof BigInteger)
                    &amp;&amp; !(value instanceof Float)
                    &amp;&amp; !(value instanceof Double)
                ) {
<span class="nc" id="L268">                throw new PlcRuntimeException(&quot;Unsupported datatype detected &quot; + value.getClass());</span>
            }
<span class="fc" id="L270">        }</span>
<span class="fc" id="L271">    }</span>

    ////////////////////////////////////////////////////////////////////////////////
    // Encoding helpers.
    ////////////////////////////////////////////////////////////////////////////////

    private boolean produceCoilValue(List&lt;?&gt; values) throws PlcProtocolException {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (values.size() != 1) {</span>
<span class="nc" id="L279">            throw new PlcProtocolException(&quot;Only one value allowed&quot;);</span>
        }
<span class="fc" id="L281">        Byte multiCoil = produceCoilValues(values)[0];</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        return multiCoil != 0;</span>
    }

    private byte[] produceCoilValues(List&lt;?&gt; values) throws PlcProtocolException {
<span class="fc" id="L286">        List&lt;Byte&gt; coils = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L287">        Byte actualCoil = 0;</span>
<span class="fc" id="L288">        int i = 7;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (Object value : values) {</span>
<span class="fc" id="L290">            boolean coilSet = false;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (value.getClass() == Boolean.class) {</span>
<span class="fc" id="L292">                coilSet = (Boolean) value;</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            } else if (value.getClass() == Byte.class) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                if ((byte) value &gt; 1) {</span>
<span class="nc" id="L295">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                coilSet = (byte) value == 1;</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            } else if (value.getClass() == byte[].class) {</span>
<span class="nc" id="L299">                byte[] bytes = (byte[]) value;</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (bytes.length != 1) {</span>
<span class="nc" id="L301">                    throw new PlcProtocolException(&quot;Only exactly one byte is allowed: &quot; + bytes.length);</span>
                }
<span class="nc" id="L303">                byte byteValue = bytes[1];</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (byteValue &gt; 1) {</span>
<span class="nc" id="L305">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="nc bnc" id="L307" title="All 2 branches missed.">                coilSet = byteValue == 1;</span>
<span class="pc bfc" id="L308" title="All 2 branches covered.">            } else if (value.getClass() == Short.class) {</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">                if ((short) value &gt; 1) {</span>
<span class="nc" id="L310">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">                coilSet = (Short) value == 1;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            } else if (value.getClass() == Integer.class) {</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                if ((int) value &gt; 1) {</span>
<span class="nc" id="L315">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + value);</span>
                }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">                coilSet = (int) value == 1;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            } else if (value.getClass() == BigInteger.class) {</span>
<span class="fc" id="L319">                coilSet = value.equals(BigInteger.ONE);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            } else if (value.getClass() == Float.class) {</span>
<span class="fc" id="L321">                coilSet = value.equals(1.0f);</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            } else if (value.getClass() == Double.class) {</span>
<span class="fc" id="L323">                coilSet = value.equals(1.0d);</span>
            } else {
<span class="nc" id="L325">                throw new PlcRuntimeException(&quot;Unsupported datatype detected &quot; + value.getClass());</span>
            }
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            byte coilToSet = (coilSet ? (byte) 1 : (byte) 0);</span>
<span class="fc" id="L328">            actualCoil = (byte) (actualCoil | coilToSet &lt;&lt; i);</span>
<span class="fc" id="L329">            i--;</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (i &lt; 0) {</span>
<span class="nc" id="L331">                coils.add(actualCoil);</span>
<span class="nc" id="L332">                actualCoil = 0;</span>
<span class="nc" id="L333">                i = 8;</span>
            }
<span class="fc" id="L335">        }</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (coils.isEmpty()) {</span>
            // We only have one coil
<span class="fc" id="L338">            return new byte[]{actualCoil};</span>
        }
<span class="nc" id="L340">        return ArrayUtils.toPrimitive(coils.toArray(new Byte[0]));</span>
    }

    private byte[] produceRegisterValue(List&lt;?&gt; values) throws PlcProtocolException {
<span class="fc" id="L344">        ByteBuf buffer = Unpooled.buffer();</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (Object value : values) {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (value.getClass() == Boolean.class) {</span>
<span class="fc" id="L347">                buffer.writeByte(0);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                buffer.writeByte((boolean) value ? 1 : 0);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            } else if (value.getClass() == Byte.class) {</span>
<span class="fc" id="L350">                buffer.writeByte(0);</span>
<span class="fc" id="L351">                buffer.writeByte((byte) value);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            } else if (value.getClass() == byte[].class) {</span>
<span class="nc" id="L353">                byte[] bytes = (byte[]) value;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (bytes.length != 2) {</span>
<span class="nc" id="L355">                    throw new PlcProtocolException(&quot;Only exactly two bytes are allowed: &quot; + bytes.length);</span>
                }
<span class="nc" id="L357">                buffer.writeBytes(bytes);</span>
<span class="pc bfc" id="L358" title="All 2 branches covered.">            } else if (value.getClass() == Short.class) {</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">                if ((short) value &lt; 0) {</span>
<span class="nc" id="L360">                    throw new PlcProtocolException(&quot;Only positive values are supported for Short: &quot; + value);</span>
                }
<span class="fc" id="L362">                buffer.writeShort((short) value);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            } else if (value.getClass() == Integer.class) {</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                if ((int) value &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L365">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Integer: &quot; + value);</span>
                }
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                if ((int) value &lt; 0) {</span>
<span class="nc" id="L368">                    throw new PlcProtocolException(&quot;Only positive values are supported for Integer: &quot; + value);</span>
                }
<span class="fc" id="L370">                buffer.writeShort((int) value);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            } else if (value.getClass() == BigInteger.class) {</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.ZERO) &lt; 0) {</span>
<span class="nc" id="L373">                    throw new PlcProtocolException(&quot;Only positive values are supported for BigInteger: &quot; + value);</span>
                }
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.valueOf(0XFFFF_FFFFL)) &gt; 0) {</span>
<span class="nc" id="L376">                    throw new PlcProtocolException(&quot;Value to high to fit into register for BigInteger: &quot; + value);</span>
                }
                // TODO: for now we can't support big values as we only write one register at once
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">                if (((BigInteger) value).compareTo(BigInteger.valueOf(0XFFFFL)) &gt; 0) {</span>
<span class="nc" id="L380">                    throw new PlcProtocolException(&quot;Value to high to fit into register for BigInteger: &quot; + value);</span>
                }
                // TODO: Register has 2 bytes so we trim to 2 instead of 4 like the second if above
<span class="fc" id="L383">                int maxBytes = 2;</span>
<span class="fc" id="L384">                byte[] bigIntegerBytes = ((BigInteger) value).toByteArray();</span>
<span class="fc" id="L385">                byte[] bytes = new byte[maxBytes];</span>
<span class="fc" id="L386">                int lengthToCopy = Math.min(bigIntegerBytes.length, maxBytes);</span>
<span class="fc" id="L387">                int srcPosition = Math.max(bigIntegerBytes.length - maxBytes, 0);</span>
<span class="fc" id="L388">                int destPosition = maxBytes - lengthToCopy;</span>
<span class="fc" id="L389">                System.arraycopy(bigIntegerBytes, srcPosition, bytes, destPosition, lengthToCopy);</span>

                // TODO: check if this is a good representation.
                // TODO: can a big integer span multiple registers?
<span class="fc" id="L393">                buffer.writeBytes(bytes);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">            } else if (value.getClass() == Float.class) {</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                if (((float) value) &lt; 0) {</span>
<span class="nc" id="L396">                    throw new PlcProtocolException(&quot;Only positive values are supported for Float: &quot; + value);</span>
                }
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                if (((float) value) &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L399">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Float: &quot; + value);</span>
                }
<span class="fc" id="L401">                buffer.writeShort(Math.round((float) value));</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            } else if (value.getClass() == Double.class) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                if (((double) value) &lt; 0) {</span>
<span class="nc" id="L404">                    throw new PlcProtocolException(&quot;Only positive values are supported for Double: &quot; + value);</span>
                }
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                if (((double) value) &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L407">                    throw new PlcProtocolException(&quot;Value to high to fit into register for Double: &quot; + value);</span>
                }
<span class="fc" id="L409">                buffer.writeShort((int) Math.round((double) value));</span>
            } else {
<span class="nc" id="L411">                throw new PlcRuntimeException(&quot;Unsupported datatype detected &quot; + value.getClass());</span>
            }
<span class="fc" id="L413">        }</span>
<span class="fc" id="L414">        byte[] result = new byte[buffer.writerIndex()];</span>
<span class="fc" id="L415">        buffer.readBytes(result);</span>
<span class="fc" id="L416">        return result;</span>
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Decoding helpers.
    ////////////////////////////////////////////////////////////////////////////////
    private &lt;T&gt; List&lt;T&gt; produceCoilValueList(RequestItem requestItem, Class&lt;T&gt; dataType, ByteBuf byteBuf) {
<span class="fc" id="L423">        ReadRequestItem readRequestItem = (ReadRequestItem) requestItem;</span>
<span class="fc" id="L424">        byte[] bytes = new byte[byteBuf.readableBytes()];</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (bytes.length &lt; 1) {</span>
<span class="nc" id="L426">            return Collections.emptyList();</span>
        }
<span class="fc" id="L428">        byteBuf.readBytes(bytes);</span>
<span class="fc" id="L429">        List&lt;T&gt; data = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (int i = 0, j = 0; data.size() &lt; readRequestItem.getSize(); i++) {</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">            if (i &gt; 7) {</span>
                // Every 8 Coils we need to increase the access
<span class="nc" id="L433">                j++;</span>
<span class="nc" id="L434">                i = 0;</span>
            }
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            boolean coilSet = (bytes[j] &amp; (1L &lt;&lt; i)) != 0;</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            byte coilFlag = coilSet ? (byte) 1 : (byte) 0;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (dataType == Boolean.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L440">                T itemToBeAdded = (T) Boolean.valueOf(coilSet);</span>
<span class="fc" id="L441">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            } else if (dataType == Byte.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L444">                T itemToBeAdded = (T) Byte.valueOf(coilFlag);</span>
<span class="fc" id="L445">                data.add(itemToBeAdded);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            } else if (dataType == byte[].class) {</span>
<span class="nc" id="L447">                data.add((T) new byte[]{coilFlag});</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            } else if (dataType == Short.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L450">                T itemToBeAdded = (T) Short.valueOf(coilFlag);</span>
<span class="fc" id="L451">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">            } else if (dataType == Integer.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L454">                T itemToBeAdded = (T) Integer.valueOf(coilFlag);</span>
<span class="fc" id="L455">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            } else if (dataType == BigInteger.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L458">                T itemToBeAdded = (T) BigInteger.valueOf(coilFlag);</span>
<span class="fc" id="L459">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">            } else if (dataType == Float.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L462">                T itemToBeAdded = (T) Float.valueOf(coilFlag);</span>
<span class="fc" id="L463">                data.add(itemToBeAdded);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">            } else if (dataType == Double.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L466">                T itemToBeAdded = (T) Double.valueOf(coilFlag);</span>
<span class="fc" id="L467">                data.add(itemToBeAdded);</span>
<span class="fc" id="L468">            } else {</span>
<span class="nc" id="L469">                throw new PlcRuntimeException(&quot;Unsupported datatype detected &quot; + dataType);</span>
            }
        }
<span class="fc" id="L472">        return data;</span>
    }

    private &lt;T&gt; List&lt;T&gt; produceRegisterValueList(RequestItem requestItem, Class&lt;T&gt; dataType, ByteBuf byteBuf) throws PlcProtocolException {
<span class="fc" id="L476">        ReadRequestItem readRequestItem = (ReadRequestItem) requestItem;</span>
<span class="fc" id="L477">        int readableBytes = byteBuf.readableBytes();</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (readableBytes % 2 != 0) {</span>
<span class="nc" id="L479">            throw new PlcProtocolException(&quot;Readables bytes should even: &quot; + readableBytes);</span>
        }
<span class="fc" id="L481">        List&lt;T&gt; data = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (int i = 0; i &lt; readRequestItem.getSize(); i++) {</span>
<span class="fc" id="L483">            byte[] register = new byte[2];</span>
<span class="fc" id="L484">            byteBuf.readBytes(register);</span>
<span class="fc" id="L485">            int intValue = register[0] &lt;&lt; 8 | register[1];</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (dataType == Boolean.class) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                T itemToBeAdded = (T) Boolean.valueOf(intValue == 1);</span>
<span class="fc" id="L489">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">            } else if (dataType == Byte.class) {</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">                if (intValue &gt; Byte.MAX_VALUE) {</span>
<span class="nc" id="L492">                    throw new PlcProtocolException(&quot;Value to high to fit into Byte: &quot; + intValue);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L495">                T itemToBeADded = (T) Byte.valueOf((byte) intValue);</span>
<span class="fc" id="L496">                data.add(itemToBeADded);</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            } else if (dataType == byte[].class) {</span>
<span class="nc" id="L498">                T itemToBeAdded = (T) register;</span>
<span class="nc" id="L499">                data.add(itemToBeAdded);</span>
<span class="pc bfc" id="L500" title="All 2 branches covered.">            } else if (dataType == Short.class) {</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                if (intValue &gt; Short.MAX_VALUE) {</span>
<span class="nc" id="L502">                    throw new PlcProtocolException(&quot;Value to high to fit into Short: &quot; + intValue);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L505">                T itemToBeAdded = (T) Short.valueOf((short) intValue);</span>
<span class="fc" id="L506">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            } else if (dataType == Integer.class) {</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                if (intValue &lt; 0) {</span>
<span class="nc" id="L509">                    throw new PlcProtocolException(&quot;Integer underflow: &quot; + intValue);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L512">                T itemToBeAdded = (T) Integer.valueOf(intValue);</span>
<span class="fc" id="L513">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">            } else if (dataType == BigInteger.class) {</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">                if (intValue &lt; 0) {</span>
<span class="nc" id="L516">                    throw new PlcProtocolException(&quot;BigInteger underflow: &quot; + intValue);</span>
                }
                // TODO: can a big integer span multiple registers?
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L520">                T itemToBeAdded = (T) new BigInteger(register);</span>
<span class="fc" id="L521">                data.add(itemToBeAdded);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            } else if (dataType == Float.class) {</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                if (intValue &lt; 0) {</span>
<span class="nc" id="L524">                    throw new PlcProtocolException(&quot;BigInteger underflow: &quot; + intValue);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L527">                T itemToBeAdded = (T) new Float(intValue);</span>
<span class="fc" id="L528">                data.add(itemToBeAdded);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            } else if (dataType == Double.class) {</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                if (intValue &lt; 0) {</span>
<span class="nc" id="L531">                    throw new PlcProtocolException(&quot;BigInteger underflow: &quot; + intValue);</span>
                }
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L534">                T itemToBeAdded = (T) new Double(intValue);</span>
<span class="fc" id="L535">                data.add(itemToBeAdded);</span>
<span class="fc" id="L536">            } else {</span>
<span class="nc" id="L537">                throw new PlcRuntimeException(&quot;Unsupported datatype detected &quot; + dataType);</span>
            }
        }
<span class="fc" id="L540">        return data;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>
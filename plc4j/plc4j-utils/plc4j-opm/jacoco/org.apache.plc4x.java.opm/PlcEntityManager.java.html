<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlcEntityManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PLC4J: Utils: Object PLC Mapping</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.java.opm</a> &gt; <span class="el_source">PlcEntityManager.java</span></div><h1>PlcEntityManager.java</h1><pre class="source lang-java linenums">/*
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 &quot;License&quot;); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */

package org.apache.plc4x.java.opm;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.implementation.bind.annotation.*;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.SystemConfiguration;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.plc4x.java.PlcDriverManager;
import org.apache.plc4x.java.api.PlcConnection;
import org.apache.plc4x.java.api.exceptions.PlcConnectionException;
import org.apache.plc4x.java.api.exceptions.PlcInvalidFieldException;
import org.apache.plc4x.java.api.exceptions.PlcRuntimeException;
import org.apache.plc4x.java.api.messages.PlcReadRequest;
import org.apache.plc4x.java.api.messages.PlcReadResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static net.bytebuddy.matcher.ElementMatchers.any;

/**
 * Plc4x equivalent of Jpas EntityManager for implementing Object-Plc-Mapping.
 * This means that calls to a plc can be done by using plain POJOs with Annotations.
 * &lt;p&gt;
 * First, the necessary annotations are {@link PlcEntity} and {@link PlcField}.
 * For a class to be usable as PlcEntity it needs
 * &lt;ul&gt;
 * &lt;li&gt;be non-final (as proxiing has to be used in case of {@link #connect(Class)}&lt;/li&gt;
 * &lt;li&gt;a public no args constructor for instanciation&lt;/li&gt;
 * &lt;li&gt;Needs to be annotated with {@link PlcEntity} and has a valid value which is the connection string&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Basically, the {@link PlcEntityManager} has to operation &quot;modes&quot; represented by the methods {@link #read(Class)} and
 * {@link #connect(Class)}.
 * &lt;p&gt;
 * For a field to get Values from the Plc Injected it needs to be annotated with the {@link PlcField} annotation.
 * The value has to be the plc fields string (which is inserted in the {@link PlcReadRequest}).
 * The connection string is taken from the value of the {@link PlcEntity} annotation on the class.
 * &lt;p&gt;
 * The {@link #read(Class)} method has no direkt equivalent in JPA (as far as I know) as it only returns a &quot;detached&quot;
 * entity. This means it fetches all values from the plc that are annotated wiht the {@link PlcField} annotations.
 * &lt;p&gt;
 * The {@link #connect(Class)} method is more JPA-like as it returns a &quot;connected&quot; entity. This means, that each
 * time one of the getters on the returned entity is called a call is made to the plc (and the field value is changed
 * for this specific field).
 * Furthermore, if a method which is no getter is called, then all {@link PlcField}s are refreshed before doing the call.
 * Thus, all operations on fields that are annotated with {@link PlcField} are always done against the &quot;live&quot; values
 * from the PLC.
 * &lt;p&gt;
 * // TODO Add detach method
 */
public class PlcEntityManager {

<span class="fc" id="L88">    private static final Logger LOGGER = LoggerFactory.getLogger(PlcEntityManager.class);</span>

<span class="fc" id="L90">    private static final Configuration CONF = new SystemConfiguration();</span>
<span class="fc" id="L91">    private static final long READ_TIMEOUT = CONF.getLong(&quot;org.apache.plc4x.java.opm.entity_manager.read_timeout&quot;, 1_000);</span>

    private final PlcDriverManager driverManager;

<span class="fc" id="L95">    public PlcEntityManager() {</span>
<span class="fc" id="L96">        this.driverManager = new PlcDriverManager();</span>
<span class="fc" id="L97">    }</span>

<span class="fc" id="L99">    public PlcEntityManager(PlcDriverManager driverManager) {</span>
<span class="fc" id="L100">        this.driverManager = driverManager;</span>
<span class="fc" id="L101">    }</span>

    public &lt;T&gt; T read(Class&lt;T&gt; clazz) throws OPMException {
<span class="fc" id="L104">        PlcEntity annotation = getPlcEntityAndCheckPreconditions(clazz);</span>
<span class="fc" id="L105">        String source = annotation.value();</span>

<span class="fc" id="L107">        try (PlcConnection connection = driverManager.getConnection(source)) {</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            if (!connection.getMetadata().canRead()) {</span>
<span class="nc" id="L109">                throw new OPMException(&quot;Unable to get Reader for connection with url '&quot; + source + &quot;'&quot;);</span>
            }

<span class="fc" id="L112">            PlcReadRequest.Builder requestBuilder = connection.readRequestBuilder();</span>

<span class="fc" id="L114">            Arrays.stream(clazz.getDeclaredFields())</span>
<span class="fc" id="L115">                .filter(field -&gt; field.isAnnotationPresent(PlcField.class))</span>
<span class="fc" id="L116">                .forEach(field -&gt;</span>
<span class="fc" id="L117">                    requestBuilder.addItem(</span>
<span class="fc" id="L118">                        field.getDeclaringClass().getName() + &quot;.&quot; + field.getName(),</span>
<span class="fc" id="L119">                        field.getAnnotation(PlcField.class).value()</span>
                    )
                );

            // Build the request
<span class="fc" id="L124">            PlcReadRequest request = requestBuilder.build();</span>

            // Perform the request
<span class="fc" id="L127">            PlcReadResponse response = getPlcReadResponse(request);</span>

            // Construct the Object
<span class="fc" id="L130">            T instance = clazz.getConstructor().newInstance();</span>

            // Fill all requested fields
<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (String fieldName : response.getFieldNames()) {</span>
<span class="fc" id="L134">                String targetFieldName = StringUtils.substringAfterLast(fieldName, &quot;.&quot;);</span>
<span class="fc" id="L135">                setField(clazz, instance, response, targetFieldName, fieldName);</span>
<span class="fc" id="L136">            }</span>
<span class="fc" id="L137">            return instance;</span>
<span class="nc" id="L138">        } catch (PlcInvalidFieldException e) {</span>
<span class="nc" id="L139">            throw new OPMException(&quot;Unable to parse one field request&quot;, e);</span>
<span class="nc" id="L140">        } catch (PlcConnectionException e) {</span>
<span class="nc" id="L141">            throw new OPMException(&quot;Unable to get connection with url '&quot; + source + &quot;'&quot;, e);</span>
<span class="nc" id="L142">        } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | NoSuchFieldException | IllegalAccessException e) {</span>
<span class="nc" id="L143">            throw new OPMException(&quot;Unable to fetch PlcEntity &quot; + clazz.getName(), e);</span>
<span class="nc" id="L144">        } catch (Exception e) {</span>
<span class="nc" id="L145">            throw new OPMException(&quot;Unknown Error&quot;, e);</span>
        }
    }

    /**
     * Returns a connected proxy.
     *
     * @param clazz clazz to be connected.
     * @param &lt;T&gt;   type of param {@code clazz}.
     * @return a connected entity.
     * @throws OPMException when proxy can't be build.
     */
    public &lt;T&gt; T connect(Class&lt;T&gt; clazz) throws OPMException {
<span class="fc" id="L158">        getPlcEntityAndCheckPreconditions(clazz);</span>
        try {
            // Use Byte Buddy to generate a subclassed proxy that delegates all PlcField Methods
            // to the intercept method
<span class="fc" id="L162">            return new ByteBuddy()</span>
<span class="fc" id="L163">                .subclass(clazz)</span>
<span class="fc" id="L164">                .method(any()).intercept(MethodDelegation.to(this))</span>
<span class="fc" id="L165">                .make()</span>
<span class="fc" id="L166">                .load(Thread.currentThread().getContextClassLoader())</span>
<span class="fc" id="L167">                .getLoaded()</span>
<span class="fc" id="L168">                .getConstructor()</span>
<span class="fc" id="L169">                .newInstance();</span>
<span class="nc" id="L170">        } catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L171">            throw new OPMException(&quot;Unable to instantiate Proxy&quot;, e);</span>
        }
    }

    private &lt;T&gt; PlcEntity getPlcEntityAndCheckPreconditions(Class&lt;T&gt; clazz) {
<span class="fc" id="L176">        PlcEntity annotation = clazz.getAnnotation(PlcEntity.class);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (annotation == null) {</span>
<span class="fc" id="L178">            throw new IllegalArgumentException(&quot;Given Class is no Plc Entity, i.e., not annotated with @PlcEntity&quot;);</span>
        }
        // Check if default constructor exists
        try {
<span class="fc" id="L182">            clazz.getConstructor();</span>
<span class="fc" id="L183">        } catch (NoSuchMethodException e) {</span>
<span class="fc" id="L184">            throw new IllegalArgumentException(&quot;Cannot use PlcEntity without default constructor&quot;, e);</span>
<span class="fc" id="L185">        }</span>
<span class="fc" id="L186">        return annotation;</span>
    }

    //------------------------------------------------------------------------------------------------
    //
    //  Methods for interception for the proxy object
    //
    //------------------------------------------------------------------------------------------------

    /**
     * Basic Intersector for all methods on the proxy object.
     * It checks if the invoked method is a getter and if so, only retrieves the requested field, forwarding to
     * the {@link #fetchValueForGetter(Object, Method)} method.
     * &lt;p&gt;
     * If the field is no getter, then all fields are refreshed by calling {@link #refetchAllFields(Object)}
     * and then, the method is invoked.
     *
     * @param proxy    Object to intercept
     * @param method   Method that was intercepted
     * @param callable Callable to call the method after fetching the values
     * @param entity   Reference to the PlcEntity
     * @return possible result of the original methods invocation
     * @throws OPMException Problems with plc / proxying
     */
    @SuppressWarnings(&quot;unused&quot;)
    @RuntimeType
    public Object intercept(@This Object proxy, @Origin Method method, @SuperCall Callable&lt;?&gt; callable, @Super Object entity) throws OPMException {
<span class="fc" id="L213">        LOGGER.trace(&quot;Invoked method {} on connected PlcEntity {}&quot;, method.getName(), entity);</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (method.getName().startsWith(&quot;get&quot;)) {</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (method.getParameterCount() &gt; 0) {</span>
<span class="nc" id="L217">                throw new OPMException(&quot;Only getter with no arguments are supported&quot;);</span>
            }
            // Fetch single value
<span class="fc" id="L220">            LOGGER.trace(&quot;Invoked method {} is getter, trying to find annotated field and return requested value&quot;,</span>
<span class="fc" id="L221">                method.getName());</span>
<span class="fc" id="L222">            return fetchValueForGetter(entity, method);</span>
        }

<span class="pc bpc" id="L225" title="3 of 6 branches missed.">        if (method.getName().startsWith(&quot;is&quot;) &amp;&amp; (method.getReturnType() == boolean.class || method.getReturnType() == Boolean.class)) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">            if (method.getParameterCount() &gt; 0) {</span>
<span class="nc" id="L227">                throw new OPMException(&quot;Only getter with no arguments are supported&quot;);</span>
            }
            // Fetch single value
<span class="fc" id="L230">            LOGGER.trace(&quot;Invoked method {} is boolean flag method, trying to find annotated field and return requested value&quot;,</span>
<span class="fc" id="L231">                method.getName());</span>
<span class="fc" id="L232">            return fetchValueForIsGetter(entity, method);</span>
        }

        // Fetch all values, than invoke method
        try {
<span class="fc" id="L237">            LOGGER.trace(&quot;Invoked method is no getter, refetch all fields and invoke method {} then&quot;, method.getName());</span>
<span class="fc" id="L238">            refetchAllFields(proxy);</span>
<span class="fc" id="L239">            return callable.call();</span>
<span class="nc" id="L240">        } catch (Exception e) {</span>
<span class="nc" id="L241">            throw new OPMException(&quot;Unable to forward invocation &quot; + method.getName() + &quot; on connected PlcEntity&quot;, e);</span>
        }
    }

    /**
     * Renews all values of all Fields that are annotated with {@link PlcEntity}.
     *
     * @param proxy Object to refresh the fields on.
     * @throws OPMException on various errors.
     */
    private void refetchAllFields(Object proxy) throws OPMException {
        // Don't log o here as this would cause a second request against a plc so don't touch it, or if you log be aware of that
<span class="fc" id="L253">        Class&lt;?&gt; entityClass = proxy.getClass().getSuperclass();</span>
<span class="fc" id="L254">        PlcEntity plcEntity = entityClass.getAnnotation(PlcEntity.class);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (plcEntity == null) {</span>
<span class="nc" id="L256">            throw new OPMException(&quot;Non PlcEntity supplied&quot;);</span>
        }

<span class="fc" id="L259">        try (PlcConnection connection = driverManager.getConnection(plcEntity.value())) {</span>
            // Catch the exception, if no reader present (see below)
            // Build the query
<span class="fc" id="L262">            PlcReadRequest.Builder requestBuilder = connection.readRequestBuilder();</span>

<span class="fc" id="L264">            Arrays.stream(entityClass.getDeclaredFields())</span>
<span class="fc" id="L265">                .filter(field -&gt; field.isAnnotationPresent(PlcField.class))</span>
<span class="fc" id="L266">                .forEach(field -&gt;</span>
<span class="fc" id="L267">                    requestBuilder.addItem(</span>
<span class="fc" id="L268">                        field.getDeclaringClass().getName() + &quot;.&quot; + field.getName(),</span>
<span class="fc" id="L269">                        field.getAnnotation(PlcField.class).value()</span>
                    )
                );

<span class="fc" id="L273">            PlcReadRequest request = requestBuilder.build();</span>

<span class="fc" id="L275">            PlcReadResponse response = getPlcReadResponse(request);</span>

            // Fill all requested fields
<span class="fc bfc" id="L278" title="All 2 branches covered.">            for (String fieldName : response.getFieldNames()) {</span>
<span class="fc" id="L279">                LOGGER.trace(&quot;Value for field &quot; + fieldName + &quot; is &quot; + response.getObject(fieldName));</span>
<span class="fc" id="L280">                String clazzFieldName = StringUtils.substringAfterLast(fieldName, &quot;.&quot;);</span>
                try {
<span class="fc" id="L282">                    setField(entityClass, proxy, response, clazzFieldName, fieldName);</span>
<span class="nc" id="L283">                } catch (NoSuchFieldException | IllegalAccessException e) {</span>
<span class="nc" id="L284">                    throw new PlcRuntimeException(e);</span>
<span class="fc" id="L285">                }</span>
<span class="fc" id="L286">            }</span>
<span class="nc" id="L287">        } catch (PlcConnectionException e) {</span>
<span class="nc" id="L288">            throw new OPMException(&quot;Problem during processing&quot;, e);</span>
<span class="nc" id="L289">        } catch (Exception e) {</span>
<span class="nc" id="L290">            throw new OPMException(&quot;Unknown Error&quot;, e);</span>
<span class="fc" id="L291">        }</span>
<span class="fc" id="L292">    }</span>


    private Object fetchValueForIsGetter(Object o, Method m) throws OPMException {
<span class="fc" id="L296">        return fetchValueForGetter(o, m, 2);</span>
    }

    private Object fetchValueForGetter(Object o, Method m) throws OPMException {
<span class="fc" id="L300">        return fetchValueForGetter(o, m, 3);</span>
    }

    // TODO: why isn't o used?
    private Object fetchValueForGetter(Object o, Method m, int prefixLength) throws OPMException {
<span class="fc" id="L305">        String s = m.getName().substring(prefixLength);</span>
        // First char to lower
<span class="fc" id="L307">        String variable = s.substring(0, 1).toLowerCase().concat(s.substring(1));</span>
<span class="fc" id="L308">        LOGGER.trace(&quot;Looking for field with name {} after invokation of getter {}&quot;, variable, m.getName());</span>
        PlcField annotation;
        try {
<span class="fc" id="L311">            annotation = m.getDeclaringClass().getDeclaredField(variable).getDeclaredAnnotation(PlcField.class);</span>
<span class="nc" id="L312">        } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L313">            throw new OPMException(&quot;Unable to identify field annotated field for call to &quot; + m.getName(), e);</span>
<span class="fc" id="L314">        }</span>
<span class="fc" id="L315">        PlcEntity plcEntity = m.getDeclaringClass().getAnnotation(PlcEntity.class);</span>
<span class="fc" id="L316">        try (PlcConnection connection = driverManager.getConnection(plcEntity.value())) {</span>
            // Catch the exception, if no reader present (see below)

            // Assume to do the query here...
<span class="fc" id="L320">            PlcReadRequest request = connection.readRequestBuilder()</span>
<span class="fc" id="L321">                .addItem(m.getName(), annotation.value())</span>
<span class="fc" id="L322">                .build();</span>

<span class="fc" id="L324">            PlcReadResponse response = getPlcReadResponse(request);</span>

<span class="fc" id="L326">            return getTyped(m.getReturnType(), response, m.getName());</span>
<span class="nc" id="L327">        } catch (ClassCastException e) {</span>
<span class="nc" id="L328">            throw new OPMException(&quot;Unable to return response as suitable type&quot;, e);</span>
<span class="nc" id="L329">        } catch (Exception e) {</span>
<span class="nc" id="L330">            throw new OPMException(&quot;Problem during processing&quot;, e);</span>
        }
    }

    /**
     * Tries to set a response Item to a field in the given object.
     * This is one by looking for a field in the class and a response item
     * which is equal to the given fieldName parameter.
     *
     * @param o               Object to set the value on
     * @param response        Response to fetch the response from
     * @param targetFieldName Name of the field in the object
     * @param sourceFieldName Name of the field in the response
     * @throws NoSuchFieldException
     * @throws IllegalAccessException
     */
    private void setField(Class&lt;?&gt; clazz, Object o, PlcReadResponse response, String targetFieldName, String sourceFieldName) throws NoSuchFieldException, IllegalAccessException {
<span class="fc" id="L347">        LOGGER.debug(&quot;setField on clazz: {}, Object: {}, response: {}, targetFieldName: {}, sourceFieldName:{} &quot;, clazz, o, response, targetFieldName, sourceFieldName);</span>
<span class="fc" id="L348">        Field field = clazz.getDeclaredField(targetFieldName);</span>
<span class="fc" id="L349">        field.setAccessible(true);</span>
        try {
<span class="fc" id="L351">            field.set(o, getTyped(field.getType(), response, sourceFieldName));</span>
<span class="nc" id="L352">        } catch (ClassCastException e) {</span>
            // TODO should we simply fail here?
<span class="nc" id="L354">            LOGGER.warn(&quot;Unable to assign return value {} to field {} with type {}&quot;, response.getObject(sourceFieldName), targetFieldName, field.getType(), e);</span>
<span class="fc" id="L355">        }</span>
<span class="fc" id="L356">    }</span>

    private Object getTyped(Class&lt;?&gt; clazz, PlcReadResponse response, String sourceFieldName) {
<span class="fc" id="L359">        LOGGER.debug(&quot;getTyped clazz: {}, response: {}, fieldName: {}&quot;, clazz, response, sourceFieldName);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (clazz.isPrimitive()) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (clazz == boolean.class) {</span>
<span class="fc" id="L362">                return response.getBoolean(sourceFieldName);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            } else if (clazz == byte.class) {</span>
<span class="fc" id="L364">                return response.getByte(sourceFieldName);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            } else if (clazz == short.class) {</span>
<span class="fc" id="L366">                return response.getShort(sourceFieldName);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            } else if (clazz == int.class) {</span>
<span class="fc" id="L368">                return response.getInteger(sourceFieldName);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            } else if (clazz == long.class) {</span>
<span class="fc" id="L370">                return response.getLong(sourceFieldName);</span>
            }
        }

<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (clazz == Boolean.class) {</span>
<span class="fc" id="L375">            return response.getBoolean(sourceFieldName);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        } else if (clazz == Byte.class) {</span>
<span class="fc" id="L377">            return response.getByte(sourceFieldName);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        } else if (clazz == Short.class) {</span>
<span class="fc" id="L379">            return response.getShort(sourceFieldName);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        } else if (clazz == Integer.class) {</span>
<span class="fc" id="L381">            return response.getInteger(sourceFieldName);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        } else if (clazz == Long.class) {</span>
<span class="fc" id="L383">            return response.getLong(sourceFieldName);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        } else if (clazz == BigInteger.class) {</span>
<span class="fc" id="L385">            return response.getBigInteger(sourceFieldName);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        } else if (clazz == Float.class) {</span>
<span class="fc" id="L387">            return response.getFloat(sourceFieldName);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        } else if (clazz == Double.class) {</span>
<span class="fc" id="L389">            return response.getDouble(sourceFieldName);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        } else if (clazz == BigDecimal.class) {</span>
<span class="fc" id="L391">            return response.getBigDecimal(sourceFieldName);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        } else if (clazz == String.class) {</span>
<span class="fc" id="L393">            return response.getString(sourceFieldName);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        } else if (clazz == LocalTime.class) {</span>
<span class="fc" id="L395">            return response.getTime(sourceFieldName);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        } else if (clazz == LocalDate.class) {</span>
<span class="fc" id="L397">            return response.getDate(sourceFieldName);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        } else if (clazz == LocalDateTime.class) {</span>
<span class="fc" id="L399">            return response.getDateTime(sourceFieldName);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        } else if (clazz == byte[].class) {</span>
<span class="fc" id="L401">            return ArrayUtils.toPrimitive(response.getByteArray(sourceFieldName));</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        } else if (clazz == Byte[].class) {</span>
<span class="fc" id="L403">            return response.getByteArray(sourceFieldName);</span>
        }

        // Fallback
<span class="nc" id="L407">        Object responseObject = response.getObject(sourceFieldName);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (clazz.isAssignableFrom(responseObject.getClass())) {</span>
<span class="nc" id="L409">            return responseObject;</span>
        }

        // If nothing matched, throw
<span class="nc" id="L413">        throw new ClassCastException(&quot;Unable to return response item &quot; + responseObject + &quot;(&quot; + responseObject.getClass() + &quot;) as instance of &quot; + clazz);</span>
    }

    /**
     * Fetch the request and do appropriate error handling
     *
     * @param request the request to get the exception from
     * @return the response from the exception.
     * @throws OPMException on {@link InterruptedException} or {@link ExecutionException} or {@link TimeoutException}
     */
    private PlcReadResponse getPlcReadResponse(PlcReadRequest request) throws OPMException {
        try {
<span class="fc" id="L425">            return request.execute().get(READ_TIMEOUT, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L426">        } catch (InterruptedException e) {</span>
<span class="nc" id="L427">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L428">            throw new OPMException(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L429">        } catch (ExecutionException e) {</span>
<span class="nc" id="L430">            throw new OPMException(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L431">        } catch (TimeoutException e) {</span>
<span class="nc" id="L432">            throw new OPMException(&quot;Timeout during fetching values&quot;, e);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>
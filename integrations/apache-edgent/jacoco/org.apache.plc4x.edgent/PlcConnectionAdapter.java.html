<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlcConnectionAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Integrations: Apache Edgent</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.edgent</a> &gt; <span class="el_source">PlcConnectionAdapter.java</span></div><h1>PlcConnectionAdapter.java</h1><pre class="source lang-java linenums">/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.plc4x.edgent;

import java.util.Calendar;

import org.apache.edgent.function.Consumer;
import org.apache.edgent.function.Function;
import org.apache.edgent.function.Supplier;
import org.apache.plc4x.java.PlcDriverManager;
import org.apache.plc4x.java.api.connection.PlcConnection;
import org.apache.plc4x.java.api.connection.PlcReader;
import org.apache.plc4x.java.api.connection.PlcWriter;
import org.apache.plc4x.java.api.exceptions.PlcException;
import org.apache.plc4x.java.api.messages.PlcReadRequest;
import org.apache.plc4x.java.api.messages.PlcReadResponse;
import org.apache.plc4x.java.api.messages.PlcWriteRequest;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcReadRequest;
import org.apache.plc4x.java.api.messages.specific.TypeSafePlcWriteRequest;
import org.apache.plc4x.java.api.model.Address;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.JsonObject;

/**
 * PlcConnectionAdapter encapsulates a plc4x {@link PlcConnection}.
 * &lt;p&gt;
 * The idea here is to use PlcConnectionAdapter to enable our Edgent Supplier/Consumer
 * instances to be isolated from the details of / variability of
 * PlcConnection mgmt and such.
 * &lt;p&gt;
 * A PlcConnectionAdapter is subject to the constraints of the underlying
 * PlcConnection for the device.
 * &lt;p&gt;
 * A single PlcConnectionAdaptor represents a single underlying PlcConnection/connection
 * to a plc device.
 * &lt;p&gt;
 * Multiple PlcConnectionAdaptor instances, hence multiple PlcConnection instances,
 * can be created for a single plc device subject to the underlying device's protocol's
 * support for multiple connections from a single client.
 * &lt;p&gt;
 * A single PlcConnectionAdapter can be used by multiple threads concurrently
 * (e.g., used by multiple PlcFunctions Consumers for {@code Topology.poll()} and/or
 * multiple Suppliers for {@code TStream.sink()}).
 *
 * @see PlcFunctions
 */
public class PlcConnectionAdapter implements AutoCloseable {

<span class="fc" id="L67">    private static final Logger logger = LoggerFactory.getLogger(PlcConnectionAdapter.class);</span>
<span class="fc" id="L68">    private static final Class&lt;?&gt;[] allowedDataTypes = new Class[]{Boolean.class, Byte.class, Short.class, Integer.class, Float.class,  String.class, Calendar.class};</span>
    
    private String plcConnectionUrl;
    private PlcConnection plcConnection;

    /*
   * NOTES:
   * - if we get to the point of the application needing some feedback (possibly control)
   *   of read or write errors, my thinking is to enhance the PlcConnectionAdapter
   *   to enable the app to register an error callback handler or such.
   */

<span class="fc" id="L80">    public PlcConnectionAdapter(PlcConnection plcConnection) {</span>
<span class="fc" id="L81">        this.plcConnection = plcConnection;</span>
<span class="fc" id="L82">    }</span>

<span class="fc" id="L84">    public PlcConnectionAdapter(String plcConnectionUrl) {</span>
<span class="fc" id="L85">        this.plcConnectionUrl = plcConnectionUrl;</span>
<span class="fc" id="L86">    }</span>

    PlcConnection getConnection() throws PlcException {
<span class="fc" id="L89">        synchronized (this) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (plcConnection == null) {</span>
<span class="fc" id="L91">                plcConnection = new PlcDriverManager().getConnection(plcConnectionUrl);</span>
            }
<span class="fc" id="L93">            return plcConnection;</span>
        }
    }

    @Override
    public void close() throws Exception {
        // only close a connection this instance created/connected
<span class="pc bpc" id="L100" title="1 of 4 branches missed.">        if (plcConnectionUrl != null &amp;&amp; plcConnection != null) {</span>
<span class="fc" id="L101">            plcConnection.close();</span>
        }
<span class="fc" id="L103">    }</span>

    public Address parseAddress(String addressString) throws PlcException {
<span class="nc" id="L106">        return getConnection().parseAddress(addressString);</span>
    }

    &lt;T&gt; Supplier&lt;T&gt; newSupplier(Class&lt;T&gt; datatype, String addressStr) {
<span class="fc" id="L110">        PlcConnectionAdapter.checkDatatype(datatype);</span>
        // satisfy sonar's &quot;Reduce number of anonymous class lines&quot; code smell
<span class="fc" id="L112">        return new MySupplier&lt;&gt;(datatype, addressStr);</span>
    }
    
    private class MySupplier&lt;T&gt; implements Supplier&lt;T&gt; {
        private static final long serialVersionUID = 1L;
        private Class&lt;T&gt; datatype;
        private String addressStr;
      
<span class="fc" id="L120">        MySupplier(Class&lt;T&gt; datatype, String addressStr) {</span>
<span class="fc" id="L121">            this.datatype = datatype;</span>
<span class="fc" id="L122">            this.addressStr = addressStr;</span>
<span class="fc" id="L123">        }</span>

        @Override
        public T get() {
<span class="fc" id="L127">            PlcConnection connection = null;</span>
<span class="fc" id="L128">            Address address = null;</span>
            try {
<span class="fc" id="L130">                connection = getConnection();</span>
<span class="fc" id="L131">                address = connection.parseAddress(addressStr);</span>
<span class="fc" id="L132">                PlcReader reader = connection.getReader()</span>
<span class="pc" id="L133">                  .orElseThrow(() -&gt; new NullPointerException(&quot;No reader available&quot;));</span>
<span class="fc" id="L134">                TypeSafePlcReadRequest&lt;T&gt; readRequest = PlcConnectionAdapter.newPlcReadRequest(datatype, address);</span>
<span class="fc" id="L135">                return reader.read(readRequest).get().getResponseItem()</span>
<span class="pc" id="L136">                  .orElseThrow(() -&gt; new IllegalStateException(&quot;No response available&quot;))</span>
<span class="fc" id="L137">                  .getValues().get(0);</span>
<span class="fc" id="L138">            } catch (Exception e) {</span>
<span class="fc" id="L139">                logger.error(&quot;reading from plc device {} {} failed&quot;, connection, address, e);</span>
<span class="fc" id="L140">                return null;</span>
            }
        }
    }

    Supplier&lt;PlcReadResponse&gt; newSupplier(PlcReadRequest readRequest) {
<span class="nc" id="L146">        return new Supplier&lt;PlcReadResponse&gt;() {</span>
            private static final long serialVersionUID = 1L;

            @Override
            public PlcReadResponse get() {
<span class="nc" id="L151">                PlcConnection connection = null;</span>
                try {
<span class="nc" id="L153">                    connection = getConnection();</span>
<span class="nc" id="L154">                    PlcReader reader = connection.getReader()</span>
<span class="nc" id="L155">                        .orElseThrow(() -&gt; new NullPointerException(&quot;No reader available&quot;));</span>
<span class="nc" id="L156">                    return reader.read(readRequest).get();</span>
<span class="nc" id="L157">                } catch (Exception e) {</span>
<span class="nc" id="L158">                    logger.error(&quot;reading from plc device {} {} failed&quot;, connection, readRequest, e);</span>
<span class="nc" id="L159">                    return null;</span>
                }
            }
        };
    }

    &lt;T&gt; Consumer&lt;T&gt; newConsumer(Class&lt;T&gt; datatype, String addressStr) {
<span class="fc" id="L166">        PlcConnectionAdapter.checkDatatype(datatype);</span>
<span class="fc" id="L167">        return new Consumer&lt;T&gt;() {</span>
            private static final long serialVersionUID = 1L;

            @Override
            public void accept(T arg0) {
<span class="fc" id="L172">                PlcConnection connection = null;</span>
<span class="fc" id="L173">                Address address = null;</span>
                try {
<span class="fc" id="L175">                    connection = getConnection();</span>
<span class="fc" id="L176">                    address = connection.parseAddress(addressStr);</span>
<span class="fc" id="L177">                    PlcWriter writer = connection.getWriter()</span>
<span class="pc" id="L178">                        .orElseThrow(() -&gt; new NullPointerException(&quot;No writer available&quot;));</span>
<span class="fc" id="L179">                    PlcWriteRequest writeReq = PlcConnectionAdapter.newPlcWriteRequest(address, arg0);</span>
<span class="fc" id="L180">                    writer.write(writeReq).get();</span>
<span class="fc" id="L181">                } catch (Exception e) {</span>
<span class="fc" id="L182">                    logger.error(&quot;writing to plc device {} {} failed&quot;, connection, address, e);</span>
<span class="fc" id="L183">                }</span>
<span class="fc" id="L184">            }</span>

        };
    }

    &lt;T&gt; Consumer&lt;JsonObject&gt; newConsumer(Class&lt;T&gt; datatype, Function&lt;JsonObject, String&gt; addressFn, Function&lt;JsonObject, T&gt; valueFn) {
<span class="fc" id="L190">        PlcConnectionAdapter.checkDatatype(datatype);</span>
<span class="fc" id="L191">        return new Consumer&lt;JsonObject&gt;() {</span>
            private static final long serialVersionUID = 1L;

            @Override
            public void accept(JsonObject jo) {
<span class="fc" id="L196">                PlcConnection connection = null;</span>
<span class="fc" id="L197">                Address address = null;</span>
                try {
<span class="fc" id="L199">                    connection = getConnection();</span>
<span class="fc" id="L200">                    String addressStr = addressFn.apply(jo);</span>
<span class="fc" id="L201">                    address = connection.parseAddress(addressStr);</span>
<span class="fc" id="L202">                    T value = valueFn.apply(jo);</span>
<span class="fc" id="L203">                    PlcWriter writer = connection.getWriter()</span>
<span class="pc" id="L204">                        .orElseThrow(() -&gt; new NullPointerException(&quot;No writer available&quot;));</span>
<span class="fc" id="L205">                    PlcWriteRequest writeReq = newPlcWriteRequest(address, value);</span>
<span class="fc" id="L206">                    writer.write(writeReq).get();</span>
<span class="fc" id="L207">                } catch (Exception e) {</span>
<span class="fc" id="L208">                    logger.error(&quot;writing to plc device {} {} failed&quot;, connection, address, e);</span>
<span class="fc" id="L209">                }</span>
<span class="fc" id="L210">            }</span>

        };
    }

    static void checkDatatype(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (Class&lt;?&gt; check: allowedDataTypes) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (check == cls)</span>
<span class="fc" id="L218">                return;</span>
        }
<span class="fc" id="L220">        throw new IllegalArgumentException(&quot;Not a legal plc data type: &quot; + cls.getSimpleName());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; TypeSafePlcWriteRequest&lt;T&gt; newPlcWriteRequest(Address address, T value) {
<span class="fc" id="L225">        Class&lt;T&gt; cls = (Class&lt;T&gt;) value.getClass();</span>
<span class="fc" id="L226">        return new TypeSafePlcWriteRequest&lt;&gt;(cls, address, value);</span>
    }

    static &lt;T&gt; TypeSafePlcReadRequest&lt;T&gt; newPlcReadRequest(Class&lt;T&gt; datatype, Address address) {
<span class="fc" id="L230">        return new TypeSafePlcReadRequest&lt;&gt;(datatype, address);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>
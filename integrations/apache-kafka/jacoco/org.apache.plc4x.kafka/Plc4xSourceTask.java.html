<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Plc4xSourceTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Integrations: Apache Kafka</a> &gt; <a href="index.source.html" class="el_package">org.apache.plc4x.kafka</a> &gt; <span class="el_source">Plc4xSourceTask.java</span></div><h1>Plc4xSourceTask.java</h1><pre class="source lang-java linenums">/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
package org.apache.plc4x.kafka;

import org.apache.kafka.common.config.AbstractConfig;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.SchemaBuilder;
import org.apache.kafka.connect.data.Struct;
import org.apache.kafka.connect.errors.ConnectException;
import org.apache.kafka.connect.source.SourceRecord;
import org.apache.kafka.connect.source.SourceTask;
import org.apache.plc4x.java.PlcDriverManager;
import org.apache.plc4x.java.api.connection.PlcConnection;
import org.apache.plc4x.java.api.connection.PlcReader;
import org.apache.plc4x.java.api.exceptions.PlcConnectionException;
import org.apache.plc4x.java.api.messages.PlcReadRequest;
import org.apache.plc4x.java.api.messages.PlcReadResponse;
import org.apache.plc4x.java.api.types.PlcResponseCode;
import org.apache.plc4x.kafka.util.VersionUtil;

import java.util.*;
import java.util.concurrent.*;

/**
 * Source Connector Task polling the data source at a given rate.
 * A timer thread is scheduled which sets the fetch flag to true every rate milliseconds.
 * When poll() is invoked, the calling thread waits until the fetch flag is set for WAIT_LIMIT_MILLIS.
 * If the flag does not become true, the method returns null, otherwise a fetch is performed.
 */
<span class="nc" id="L46">public class Plc4xSourceTask extends SourceTask {</span>
    private final static long WAIT_LIMIT_MILLIS = 100;
    private final static long TIMEOUT_LIMIT_MILLIS = 5000;

    private final static String URL_FIELD = &quot;url&quot;;
    private final static String QUERY_FIELD = &quot;query&quot;;

<span class="nc" id="L53">    private final static Schema KEY_SCHEMA =</span>
        new SchemaBuilder(Schema.Type.STRUCT)
<span class="nc" id="L55">            .field(URL_FIELD, Schema.STRING_SCHEMA)</span>
<span class="nc" id="L56">            .field(QUERY_FIELD, Schema.STRING_SCHEMA)</span>
<span class="nc" id="L57">            .build();</span>

    private String topic;
    private String url;
    private List&lt;String&gt; queries;

    private PlcConnection plcConnection;
    private PlcReader plcReader;
    private PlcReadRequest plcRequest;



    // TODO: should we use shared (static) thread pool for this?
    private ScheduledExecutorService scheduler;
    private ScheduledFuture&lt;?&gt; timer;
<span class="nc" id="L72">    private boolean fetch = true;</span>

    @Override
    public String version() {
<span class="nc" id="L76">        return VersionUtil.getVersion();</span>
    }

    @Override
    public void start(Map&lt;String, String&gt; props) {
<span class="nc" id="L81">        AbstractConfig config = new AbstractConfig(Plc4xSourceConnector.CONFIG_DEF, props);</span>
<span class="nc" id="L82">        topic = config.getString(Plc4xSourceConnector.TOPIC_CONFIG);</span>
<span class="nc" id="L83">        url = config.getString(Plc4xSourceConnector.URL_CONFIG);</span>
<span class="nc" id="L84">        queries = config.getList(Plc4xSourceConnector.QUERIES_CONFIG);</span>

<span class="nc" id="L86">        openConnection();</span>

<span class="nc" id="L88">        plcReader = plcConnection.getReader()</span>
<span class="nc" id="L89">            .orElseThrow(() -&gt; new ConnectException(&quot;PlcReader not available for this type of connection&quot;));</span>


<span class="nc" id="L92">        PlcReadRequest.Builder builder = plcReader.readRequestBuilder();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        for (String query : queries) {</span>
<span class="nc" id="L94">            builder.addItem(query, query);</span>
<span class="nc" id="L95">        }</span>
<span class="nc" id="L96">        plcRequest = builder.build();</span>

<span class="nc" id="L98">        int rate = Integer.valueOf(props.get(Plc4xSourceConnector.RATE_CONFIG));</span>
<span class="nc" id="L99">        scheduler = Executors.newScheduledThreadPool(1);</span>
<span class="nc" id="L100">        timer = scheduler.scheduleAtFixedRate(Plc4xSourceTask.this::scheduleFetch, rate, rate, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L101">    }</span>

    @Override
    public void stop() {
<span class="nc" id="L105">        timer.cancel(true);</span>
<span class="nc" id="L106">        scheduler.shutdown();</span>
<span class="nc" id="L107">        closeConnection();</span>
<span class="nc" id="L108">    }</span>

    @Override
    public List&lt;SourceRecord&gt; poll() throws InterruptedException {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        return awaitFetch(WAIT_LIMIT_MILLIS) ? doFetch() : null;</span>
    }

    private void openConnection() {
        try {
<span class="nc" id="L117">            plcConnection = new PlcDriverManager().getConnection(url);</span>
<span class="nc" id="L118">            plcConnection.connect();</span>
<span class="nc" id="L119">        } catch (PlcConnectionException e) {</span>
<span class="nc" id="L120">            throw new ConnectException(&quot;Could not establish a PLC connection&quot;, e);</span>
<span class="nc" id="L121">        }</span>
<span class="nc" id="L122">    }</span>

    private void closeConnection() {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (plcConnection != null) {</span>
            try {
<span class="nc" id="L127">                plcConnection.close();</span>
<span class="nc" id="L128">            } catch (Exception e) {</span>
<span class="nc" id="L129">                throw new RuntimeException(&quot;Caught exception while closing connection to PLC&quot;, e);</span>
<span class="nc" id="L130">            }</span>
        }
<span class="nc" id="L132">    }</span>

    /**
     * Schedule next fetch operation.
     */
    private synchronized void scheduleFetch() {
<span class="nc" id="L138">        fetch = true;</span>
<span class="nc" id="L139">        notify();</span>
<span class="nc" id="L140">    }</span>

    /**
     * Wait for next scheduled fetch operation.
     * @param milliseconds maximum time to wait
     * @throws InterruptedException if the thread is interrupted
     * @return true if a fetch should be performed, false otherwise
     */
    private synchronized boolean awaitFetch(long milliseconds) throws InterruptedException {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (!fetch) {</span>
<span class="nc" id="L150">            wait(milliseconds);</span>
        }
        try {
<span class="nc" id="L153">            return fetch;</span>
        } finally {
<span class="nc" id="L155">            fetch = false;</span>
        }
    }

    private List&lt;SourceRecord&gt; doFetch() throws InterruptedException {
<span class="nc" id="L160">        final CompletableFuture&lt;PlcReadResponse&lt;?&gt;&gt; response = plcReader.read(plcRequest);</span>
        try {
<span class="nc" id="L162">            final PlcReadResponse&lt;?&gt; received = response.get(TIMEOUT_LIMIT_MILLIS, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L163">            return extractValues(received);</span>
<span class="nc" id="L164">        } catch (ExecutionException e) {</span>
<span class="nc" id="L165">            throw new ConnectException(&quot;Could not fetch data from source&quot;, e);</span>
<span class="nc" id="L166">        } catch (TimeoutException e) {</span>
<span class="nc" id="L167">            throw new ConnectException(&quot;Timed out waiting for data from source&quot;, e);</span>
        }
    }

    private List&lt;SourceRecord&gt; extractValues(PlcReadResponse&lt;?&gt; response) {
<span class="nc" id="L172">        final List&lt;SourceRecord&gt; result = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (String query : queries) {</span>
<span class="nc" id="L174">            final PlcResponseCode rc = response.getResponseCode(query);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (!rc.equals(PlcResponseCode.OK))  {</span>
<span class="nc" id="L176">                continue;</span>
            }

<span class="nc" id="L179">            Struct key = new Struct(KEY_SCHEMA)</span>
<span class="nc" id="L180">                .put(URL_FIELD, url)</span>
<span class="nc" id="L181">                .put(QUERY_FIELD, query);</span>

<span class="nc" id="L183">            Object value = response.getObject(query);</span>
<span class="nc" id="L184">            Schema valueSchema = getSchema(value);</span>
<span class="nc" id="L185">            Long timestamp = System.currentTimeMillis();</span>
<span class="nc" id="L186">            Map&lt;String, String&gt; sourcePartition = new HashMap&lt;&gt;();</span>
<span class="nc" id="L187">            sourcePartition.put(&quot;url&quot;, url);</span>
<span class="nc" id="L188">            sourcePartition.put(&quot;query&quot;, query);</span>
<span class="nc" id="L189">            Map&lt;String, Long&gt; sourceOffset = Collections.singletonMap(&quot;offset&quot;, timestamp);</span>

<span class="nc" id="L191">            SourceRecord record =</span>
                new SourceRecord(
                    sourcePartition,
                    sourceOffset,
                    topic,
                    KEY_SCHEMA,
                    key,
                    valueSchema,
                    value
                );

<span class="nc" id="L202">            result.add(record);</span>
<span class="nc" id="L203">        }</span>

<span class="nc" id="L205">        return result;</span>
    }

    private Schema getSchema(Object value) {
<span class="nc" id="L209">        Objects.requireNonNull(value);</span>

<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (value instanceof Byte)</span>
<span class="nc" id="L212">            return Schema.INT8_SCHEMA;</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (value instanceof Short)</span>
<span class="nc" id="L215">            return Schema.INT16_SCHEMA;</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (value instanceof Integer)</span>
<span class="nc" id="L218">            return Schema.INT32_SCHEMA;</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (value instanceof Long)</span>
<span class="nc" id="L221">            return Schema.INT64_SCHEMA;</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (value instanceof Float)</span>
<span class="nc" id="L224">            return Schema.FLOAT32_SCHEMA;</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (value instanceof Double)</span>
<span class="nc" id="L227">            return Schema.FLOAT64_SCHEMA;</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (value instanceof Boolean)</span>
<span class="nc" id="L230">            return Schema.BOOLEAN_SCHEMA;</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (value instanceof String)</span>
<span class="nc" id="L233">            return Schema.STRING_SCHEMA;</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (value instanceof byte[])</span>
<span class="nc" id="L236">            return Schema.BYTES_SCHEMA;</span>

        // TODO: add support for collective and complex types
<span class="nc" id="L239">        throw new ConnectException(String.format(&quot;Unsupported data type %s&quot;, value.getClass().getName()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>